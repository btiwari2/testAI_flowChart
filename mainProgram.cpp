#pragma region libraries // Libraries to include in program 

#pragma region librariesRTLoop
#include <unistd.h>   // Provides access to the POSIX (Portable Operating System Interface) operating system API, like read(), write(), and usleep().
#include <pthread.h>  // Used for creating and managing POSIX threads, mutexes, and other thread-related functions.
#include <sched.h>    // Used for setting thread scheduling parameters (e.g., sched_setscheduler).
#include <sys/mman.h> // Used for memory management functions like mlockall() and munlockall() to prevent paging.
#include <sys/stat.h>   // Used to set file permissions to the folder.
#include <ctime>      // Contains functions for handling time, such as time() and difftime().
#include <cstring>    // Provides functions for dealing with C-style strings, such as strlen() and strcat().
#include <cstdlib>    // Provides general-purpose functions like malloc(), free(), and system(), among others.
#include <vector>
#include <fstream>
#include <random>
#include <chrono>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <iostream>
#include <sstream>
#include <string>
#include <filesystem>
#include <iostream>
#include <random>
#pragma endregion

#pragma region librariesMATH
    #include <cmath> 
#pragma endregion

#pragma region librariesOpenCV
#include <opencv2/opencv.hpp> // Libraries for OpenCV
#include <opencv2/core.hpp> // Libraries for OpenCV
#include <opencv2/imgproc.hpp> // Libraries for OpenCV
#include <opencv2/highgui.hpp> // Libraries for OpenCV
#pragma endregion

#pragma region librariesNIDAQmx
#include <NIDAQmx.h>
#pragma endregion

#pragma region librariesLineScanner
// #include "/home/dmf/Documents/GitHub/DeviceTesting/MicroEpsilonLineScanner/SourceCode_Empty/Modules/Linescanner/GetProfilesCallback.h"
#pragma endregion

#pragma region librariesAerotech
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>
    #include <stdbool.h>
    #include <string.h>
    #include <ctype.h>
    #include <stdio.h>
    #include <inttypes.h>
    #include <stdint.h>
    #include <inttypes.h> // Include this for PRId64
    #include "Automation1.h"
#pragma endregion

#pragma region librariesOptrisCam

    #include "libirimager/direct_binding.h"
    #include <memory>
    // This also needs opencv libraries: <opencv2/highgui/highgui_c.h> <opencv2/opencv.hpp> <iostream>; However these are included in OpenCV regions and RTLoop region so not duplicated here.

#pragma endregion

#pragma region librariesVisualCam
    #include "Spinnaker.h"
    #include "SpinGenApi/SpinnakerGenApi.h"
#pragma endregion

#pragma region librariesNameSpace
// NameSpace Declaration
using namespace std;
using namespace cv;

// NameSpace for FLIR Camera
using namespace Spinnaker;
using namespace Spinnaker::GenApi;
using namespace Spinnaker::GenICam;

#pragma endregion


#pragma endregion

#pragma region LoopRateAndDatasetLocation // Set execution parameters 
int end_delay_time = 10; // sec
int time_delay_start = 10; // sec
int motion_time_sec = 3000; // sec

int total_time  = time_delay_start+motion_time_sec+end_delay_time;//205;//125;//125; 5 // sec

float64 sample_period = 100; // milli sec
float64 sample_period_s = sample_period*0.001; 
bool debug_lines = false;
bool bool_saveThermalData = true;
bool ILC_PowerUpdateEnable = false; // Code will enable this

double optical_efficiency = 1.0; // This is stupidity to scale the power, just call the power the power do not give apply this.
double maxlimit_laserpower_watt = 350;
double minlimit_laserpower_watt = 10;

double desired_laserpower_watt = 45.0;
double desired_temperature_celcius = 950.0;

bool closedLoopControllerEnable = false;
bool openLoopConstantLaserPowerEnable = true;
bool closedLoopStartAndOpenLoopDepositEnable = false;
bool flag_directionalCorrection = false;

// Memory for ILC correction
float64 desired_laser_power = desired_laserpower_watt;
float64 min_diff = 0.0;
float64 diff = 0.0;
std::size_t closest_idx = 0;

std::string folder = "DatasetExpBalark/Exp16_WallDeposition/Exp11_Test";
std::string file = "CPPlog.csv";
std::filesystem::path folderPath(folder);
std::filesystem::path filePath = folderPath / file;
std::string filename = filePath.string();

struct period_info {
        struct timespec next_period; // Structure to store the next period time
        long period_ns; // Variable to store the period duration in nanoseconds
};

struct task_timestamps {
    struct timespec start_time;  // Time when loop execution / do_rt_task starts
    struct timespec end_time;    // Time when do_rt_task ends
    struct timespec end_time_loop;    // Time when loop execution ends
};


#pragma endregion

#pragma region MemoryAllocationLarge // Prealloacte memory for program

// Calculate the number of samples
int num_samples_mem_allocation = ( (total_time * 1000) / sample_period ) + 1; // Tolerance

std::vector<task_timestamps> timestamps(num_samples_mem_allocation);  // Vector to store timestamps of each loop
std::vector<int32> loopIterations(num_samples_mem_allocation, 0); // Vector to store the loop iteration number (unit)


std::vector<float64> lineScanData_profileX(num_samples_mem_allocation, 0.0);
std::vector<float64> lineScanData_profileY(num_samples_mem_allocation, 0.0); 
std::vector<float64> lineScanData_profileZ(num_samples_mem_allocation, 0.0); 

std::vector<float64> laserData_cmdV(num_samples_mem_allocation, 0.0); // Vector to store commanded laser power to the IPG laser
std::vector<float64> laserData_fbkV(num_samples_mem_allocation, 0.0); // Vector to store feedback laser power from the IPG laser

std::vector<float64> laserData_ChirpSignal(num_samples_mem_allocation, 0.0); // Vector to store feedback laser power from the IPG laser


std::vector<float64> laserData_cmdW(num_samples_mem_allocation, 0.0); // Vector to store commanded laser power to the IPG laser this value can be trimmed later on
std::vector<float64> laserData_fbkW(num_samples_mem_allocation, 0.0); // Vector to store feedback laser power from the IPG laser

std::vector<float64> confocalData_distance(num_samples_mem_allocation, 0.0); // Vector to store commanded laser power to the IPG laser this value can be trimmed later on
std::vector<float64> confocalData_intensity(num_samples_mem_allocation, 0.0); // Vector to store feedback laser power from the IPG laser

std::vector<float64> forceSensorData_Z(num_samples_mem_allocation, 0.0); // Vector to store force sensor data 

std::vector<float64> optris_workzoneRawTemp(num_samples_mem_allocation, 0.0); // // Vector to store the mean of the top 400 hottest pixels from the thermal camera (workzone temperature observed without angle correction, raw data)
std::vector<float64> optris_observedMaxTemp(num_samples_mem_allocation, 0.0); // Vector to store the observed maximum temperature from the thermal camera (raw, no correction for directional dependence or averaging)
std::vector<float64> optris_workzoneCorrectedTemp(num_samples_mem_allocation, 0.0); // Vector to store the estimated true temperature of the workzone, after applying angle correction to account for directional viewing dependence
std::vector<float64> optris_observationAngle(num_samples_mem_allocation, 0.0); // Vector to store the observation angle for each measurement, used for applying angular correction to temperature readings

std::vector<float64> time_vector_lowPrecision(num_samples_mem_allocation, 0.0);
std::vector<float64> laserController_referenceRawTemp(num_samples_mem_allocation, 0.0); // Vector to store true reference temperature



std::vector<vector<vector<float64>>> optris_TempSlices(num_samples_mem_allocation, vector<vector<float64>>(640, vector<float64>(120, 0.0)));

int ilc_vector_length = 1600;
std::vector<vector<vector<float64>>> ILC_laserPower(10, vector<vector<float64>>(ilc_vector_length, vector<float64>(1, 44.0)));
std::vector<vector<vector<float64>>> ILC_maxTemp(10, vector<vector<float64>>(ilc_vector_length, vector<float64>(1, 0.0)));


std::vector<float64> aerotech_z_axis_posFbk(num_samples_mem_allocation, 0.0);
std::vector<float64> aerotech_y_axis_posFbk(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_x_axis_posFbk(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_f_axis_posFbk(num_samples_mem_allocation, 0.0); 

std::vector<float64> aerotech_z_axis_velFbk(num_samples_mem_allocation, 0.0);
std::vector<float64> aerotech_y_axis_velFbk(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_x_axis_velFbk(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_f_axis_velFbk(num_samples_mem_allocation, 0.0); 

std::vector<float64> aerotech_z_axis_accFbk(num_samples_mem_allocation, 0.0);
std::vector<float64> aerotech_y_axis_accFbk(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_x_axis_accFbk(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_f_axis_accFbk(num_samples_mem_allocation, 0.0); 

std::vector<float64> aerotech_z_axis_posCmd(num_samples_mem_allocation, 0.0);
std::vector<float64> aerotech_y_axis_posCmd(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_x_axis_posCmd(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_f_axis_posCmd(num_samples_mem_allocation, 0.0); 

std::vector<float64> aerotech_z_axis_velCmd(num_samples_mem_allocation, 0.0);
std::vector<float64> aerotech_y_axis_velCmd(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_x_axis_velCmd(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_f_axis_velCmd(num_samples_mem_allocation, 0.0); 

std::vector<float64> aerotech_z_axis_accCmd(num_samples_mem_allocation, 0.0);
std::vector<float64> aerotech_y_axis_accCmd(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_x_axis_accCmd(num_samples_mem_allocation, 0.0); 
std::vector<float64> aerotech_f_axis_accCmd(num_samples_mem_allocation, 0.0); 

std::vector<float64> pathLength_mm(num_samples_mem_allocation, 0.0); // Vector to store path length


std::vector<float64> aerotech_z_axis_DO(num_samples_mem_allocation, 0.0); 

std::vector<float64> forceSensor3AxisData_X(num_samples_mem_allocation, 0.0); // Vector to store force sensor data 
std::vector<float64> forceSensor3AxisData_Y(num_samples_mem_allocation, 0.0); // Vector to store force sensor data 
std::vector<float64> forceSensor3AxisData_Z(num_samples_mem_allocation, 0.0); // Vector to store force sensor data 


// 
int chirp_index = 0;


#pragma region chirpSignal

constexpr std::size_t kChirpSamples = 111;
constexpr float64 power[kChirpSamples] = {
    150.00000000, 150.08634513, 150.21970341, 150.40001791, 150.62714510, 150.90079520, 151.22045723, 151.58530929, 
    151.99411469, 152.44510524, 152.93585336, 153.46313544, 154.02279000, 154.60957478, 155.21702860, 155.83734470, 
    156.46126402, 157.07799800, 157.67519217, 158.23894256, 158.75387835, 159.20332415, 159.56955534, 159.83415866, 
    159.97850821, 159.98436333, 159.83459003, 159.51400121, 159.01030227, 158.31511922, 157.42507478, 156.34286572, 
    155.07828163, 153.64909284, 152.08172418, 150.41162271, 148.68322395, 146.94942282, 145.27046565, 143.71219845, 
    142.34363666, 141.23386217, 140.44830554, 140.04453279, 140.06772453, 140.54610641, 141.48665720, 142.87147800, 
    144.65524271, 146.76415850, 149.09683451, 151.52738090, 153.91093310, 156.09161645, 157.91273985, 159.22874505, 
    159.91816030, 159.89654119, 159.12816036, 157.63507149, 155.50215788, 152.87691806, 149.96306257, 147.00750275, 
    144.28098797, 142.05344517, 140.56591975, 140.00180711, 140.46067637, 141.93829439, 144.31633953, 147.36466721, 
    150.75782458, 154.10585756, 156.99744957, 159.05130828, 159.96978278, 159.58730462, 157.90574937, 155.10949421, 
    151.55494117, 147.73252881, 144.20346408, 141.51802275, 140.12653535, 140.29723469, 142.05616219, 145.16270400, 
    149.12983353, 153.29109378, 156.90767692, 159.30011101, 159.98185974, 158.76842732, 155.83680361, 151.71694640, 
    147.20899192, 143.23523565, 140.65169816, 140.05665766, 141.63931399, 145.10814043, 149.72471702, 154.44660760, 
    158.15634839, 159.92899601, 159.27473631, 156.29150212, 151.67819958, 146.59050599, 142.36203971
};
#pragma endregion

#pragma region lookupTable

constexpr std::size_t kLookupSamples = 872;

constexpr float64 pathLength[kLookupSamples] = {
    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.003700,    0.020300,    0.059900,    0.132500,    0.248100,    0.416700,    0.648300,    0.946800,    1.303700,    1.709000,    2.152700,    2.624900,    3.115500,    3.614500,    4.114500,    4.614500,    5.114500,    5.614500,    6.114500,    6.614500,    7.114500,    7.614500,    8.114400,    8.613200,    9.112000,    9.610400,    10.108700,    10.607900,    11.106700,    11.606700,    12.106700,    12.606700,    13.106700,    13.606700,    14.106700,    14.606700,    15.106700,    15.606700,    16.106700,    16.606700,    17.106700,    17.606700,    18.106700,    18.606700,    19.106700,    19.606700,    20.106700,    20.606700,    21.106700,    21.606700,    22.106700,    22.606700,    23.106700,    23.606700,    24.106700,    24.606700,    25.106700,    25.606700,    26.106700,    26.606700,    27.106700,    27.604800,    28.104000,    28.602400,    29.101200,    29.599900,    30.098600,    30.603500,    31.098500,    31.598500,    32.098500,    32.598500,    33.098500,    33.598500,    34.098500,    34.598500,    35.098500,    35.598500,    36.098500,    36.598500,    37.098500,    37.598500,    38.098500,    38.598500,    39.098500,    39.598500,    40.098500,    40.598500,    41.098500,    41.598500,    42.098500,    42.603500,    43.098500,    43.598500,    44.098500,    44.598500,    45.098500,    45.598500,    46.098500,    46.597700,    47.096300,    47.595200,    48.093600,    48.593000,    49.091400,    49.591000,    50.091000,    50.591000,    51.091000,    51.591000,    52.091000,    52.591000,    53.091000,    53.591000,    54.091000,    54.591000,    55.091000,    55.591000,    56.091000,    56.596000,    57.091000,    57.591000,    58.091000,    58.591000,    59.091000,    59.591000,    60.091000,    60.591000,    61.091000,    61.591000,    62.091000,    62.591000,    63.091000,    63.591000,    64.091000,    64.596000,    65.091000,    65.590100,    66.089100,    66.588100,    67.086800,    67.585500,    68.084000,    68.582900,    69.082900,    69.582900,    70.082900,    70.582900,    71.082900,    71.582900,    72.082900,    72.582900,    73.082900,    73.580200,    74.065800,    74.529600,    74.961400,    75.351300,    75.689200,    75.965000,    76.173600,    76.323100,    76.423400,    76.484700,    76.517100,    76.530600,    76.534900,    76.547900,    76.603900,    76.740900,    76.954900,    77.214900,    77.485900,    77.728900,    77.907900,    77.998900,    78.028900,    78.034100,    78.041800,    78.063400,    78.108800,    78.188100,    78.311400,    78.488800,    78.730100,    79.037800,    79.402600,    79.814400,    80.263300,    80.739100,    81.231700,    81.731200,    82.231200,    82.731200,    83.231200,    83.731200,    84.231200,    84.731200,    85.231200,    85.731200,    86.231000,    86.729700,    87.228100,    87.727100,    88.225300,    88.724900,    89.223300,    89.723300,    90.223300,    90.723300,    91.223300,    91.723300,    92.223300,    92.723300,    93.223300,    93.723300,    94.223300,    94.723300,    95.223300,    95.723300,    96.223300,    96.723300,    97.223300,    97.723300,    98.223300,    98.723300,    99.223300,    99.723300,    100.223300,    100.723300,    101.223300,    101.723300,    102.223300,    102.723300,    103.223300,    103.723300,    104.223300,    104.723300,    105.223300,    105.722200,    106.220300,    106.719000,    107.217900,    107.716600,    108.215300,    108.715200,    109.215200,    109.720200,    110.215200,    110.715200,    111.215200,    111.715200,    112.215200,    112.715200,    113.215200,    113.715200,    114.215200,    114.715200,    115.215200,    115.715200,    116.215200,    116.715200,    117.215200,    117.715200,    118.215200,    118.715200,    119.215200,    119.715200,    120.215200,    120.715200,    121.215200,    121.720200,    122.215200,    122.715200,    123.215200,    123.715200,    124.215200,    124.714100,    125.212900,    125.711400,    126.210100,    126.709300,    127.207400,    127.707600,    128.207600,    128.707600,    129.207600,    129.707600,    130.207600,    130.707600,    131.207600,    131.707600,    132.207600,    132.707600,    133.207600,    133.707600,    134.207600,    134.707600,    135.207600,    135.707600,    136.207600,    136.707600,    137.207600,    137.707600,    138.207600,    138.707600,    139.207600,    139.707600,    140.207600,    140.707600,    141.207600,    141.707600,    142.207600,    142.707600,    143.207600,    143.706900,    144.205900,    144.703900,    145.202700,    145.701700,    146.200200,    146.699300,    147.199300,    147.699300,    148.199300,    148.699300,    149.199300,    149.699300,    150.199300,    150.699300,    151.199300,    151.695300,    152.178000,    152.637100,    153.062600,    153.444500,    153.772600,    154.037000,    154.235000,    154.375500,    154.468600,    154.524300,    154.552800,    154.564100,    154.567800,    154.585800,    154.651800,    154.800800,    155.026800,    155.292800,    155.561800,    155.796800,    155.960800,    156.038800,    156.062800,    156.066500,    156.075800,    156.100700,    156.151100,    156.237100,    156.368700,    156.556200,    156.809000,    157.127000,    157.500400,    157.919200,    158.373300,    158.852600,    159.347100,    159.846900,    160.346900,    160.846900,    161.346900,    161.846900,    162.346900,    162.851900,    163.346900,    163.846900,    164.346300,    164.845000,    165.343600,    165.842400,    166.341100,    166.840100,    167.339100,    167.839100,    168.339100,    168.839100,    169.339100,    169.839100,    170.339100,    170.839100,    171.339100,    171.839100,    172.339100,    172.839100,    173.339100,    173.839100,    174.339100,    174.839100,    175.339100,    175.839100,    176.339100,    176.839100,    177.339100,    177.839100,    178.344100,    178.839100,    179.339100,    179.839100,    180.339100,    180.839100,    181.339100,    181.839100,    182.339100,    182.839100,    183.339100,    183.837600,    184.336300,    184.835100,    185.333900,    185.832600,    186.331300,    186.831300,    187.331300,    187.831300,    188.331300,    188.831300,    189.331300,    189.831300,    190.331300,    190.831300,    191.331300,    191.831300,    192.331300,    192.831300,    193.331300,    193.831300,    194.331300,    194.831300,    195.331300,    195.831300,    196.331300,    196.831300,    197.331300,    197.831300,    198.331300,    198.831300,    199.331300,    199.831300,    200.331300,    200.831300,    201.331300,    201.831300,    202.331300,    202.830000,    203.328900,    203.827200,    204.326100,    204.824900,    205.323500,    205.823500,    206.323500,    206.823500,    207.323500,    207.823500,    208.323500,    208.823500,    209.323500,    209.823500,    210.323500,    210.823500,    211.323500,    211.823500,    212.323500,    212.823500,    213.323500,    213.823500,    214.343500,    214.823500,    215.323500,    215.823500,    216.323500,    216.823500,    217.323500,    217.823500,    218.323500,    218.823500,    219.323500,    219.823500,    220.323500,    220.823500,    221.323500,    221.822500,    222.321400,    222.820000,    223.318700,    223.817100,    224.315900,    224.815400,    225.315400,    225.815400,    226.315400,    226.820400,    227.315400,    227.815400,    228.315400,    228.815400,    229.315200,    229.809700,    230.289100,    230.743200,    231.162100,    231.535700,    231.853800,    232.106800,    232.294400,    232.426200,    232.512300,    232.562700,    232.587600,    232.597000,    232.600700,    232.624700,    232.702700,    232.866700,    233.101700,    233.370700,    233.636700,    233.861700,    234.011700,    234.077700,    234.095700,    234.099400,    234.110600,    234.139100,    234.194700,    234.287700,    234.428100,    234.625900,    234.890200,    235.218200,    235.599900,    236.025300,    236.484400,    236.966900,    237.463000,    237.962900,    238.462900,    238.962900,    239.462900,    239.962900,    240.462900,    240.962900,    241.462900,    241.962900,    242.462000,    242.960700,    243.459200,    243.958200,    244.456300,    244.955400,    245.454800,    245.954800,    246.454800,    246.954800,    247.454800,    247.954800,    248.454800,    248.954800,    249.454800,    249.954800,    250.454800,    250.954800,    251.454800,    251.959800,    252.454800,    252.954800,    253.454800,    253.954800,    254.454800,    254.954800,    255.454800,    255.954800,    256.454800,    256.954800,    257.454800,    257.954800,    258.454800,    258.954800,    259.454800,    259.954800,    260.464800,    260.954800,    261.454900,    261.952900,    262.466700,    262.970500,    263.449500,    263.948100,    264.446900,    264.946900,    265.441900,    265.956900,    266.446900,    266.946900,    267.446900,    267.946900,    268.451900,    268.946900,    269.446900,    269.946900,    270.446900,    270.946900,    271.446900,    271.941900,    272.446900,    272.946900,    273.446900,    273.946900,    274.446900,    274.946900,    275.446900,    275.946900,    276.446900,    276.946900,    277.446900,    277.946900,    278.446900,    278.946900,    279.446900,    279.946900,    280.446900,    280.945500,    281.444200,    281.938100,    282.442300,    282.935300,    283.439400,    283.934400,    284.439400,    284.939400,    285.439400,    285.939400,    286.439400,    286.934400,    287.434400,    287.944400,    288.439400,    288.934400,    289.434400,    289.934400,    290.434400,    290.934400,    291.434400,    291.954400,    292.439400,    292.934400,    293.439400,    293.939400,    294.434400,    294.939400,    295.434400,    295.934400,    296.434400,    296.939400,    297.434400,    297.939400,    298.434400,    298.939400,    299.439400,    299.937800,    300.431800,    300.930100,    301.434200,    301.932900,    302.426700,    302.931400,    303.431400,    303.926400,    304.426400,    304.926400,    305.431400,    305.926400,    306.431400,    306.931400,    307.426000,    307.918800,    308.399500,    308.844300,    309.264700,    309.622800,    309.940000,    310.176700,    310.354700,    310.477300,    310.557000,    310.602700,    310.623800,    310.630200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200,    310.631200
};

constexpr float64 laserPower[kLookupSamples] = {
    46.80480000,    46.80110000,    46.80140000,    46.80860000,    46.81420000,    46.80750000,    46.80510000,    46.78920000,    46.78330000,    46.78190000,    46.77930000,    46.78410000,    46.78590000,    46.78510000,    46.77440000,    46.77510000,    46.77260000,    46.76440000,    46.77170000,    46.76800000,    46.77220000,    46.77140000,    46.78390000,    46.77680000,    46.77810000,    46.77570000,    46.76960000,    46.76190000,    46.75770000,    46.76220000,    46.75980000,    46.75790000,    46.76790000,    46.76820000,    46.75960000,    46.75110000,    46.75250000,    46.74470000,    46.75370000,    46.75040000,    46.74810000,    46.75130000,    46.74870000,    46.74450000,    46.74160000,    46.74020000,    46.74660000,    46.74030000,    46.74120000,    46.72640000,    46.73960000,    46.73370000,    46.74010000,    46.74330000,    46.74900000,    46.73620000,    46.73620000,    46.72830000,    46.71960000,    46.72460000,    46.72410000,    46.72320000,    46.71670000,    46.71150000,    46.72050000,    46.71790000,    46.71770000,    46.71620000,    46.72110000,    46.71900000,    46.71900000,    46.71900000,    46.71900000,    46.71900000,    46.71900000,    51.42710000,    51.42350000,    51.42670000,    51.43370000,    51.44170000,    51.43030000,    51.42630000,    51.41470000,    51.41900000,    51.41520000,    51.41000000,    51.41460000,    51.41100000,    51.40440000,    51.40580000,    51.41090000,    51.41640000,    51.41580000,    51.41160000,    51.41600000,    51.42400000,    51.43220000,    51.43090000,    51.43290000,    51.43680000,    51.43190000,    51.42870000,    61.43060000,    62.51600000,    63.68140000,    64.93280000,    66.59930000,    68.17230000,    70.00170000,    71.91720000,    73.76640000,    75.33820000,    76.64340000,    77.36640000,    76.81240000,    74.86590000,    72.63180000,    70.08240000,    68.36300000,    66.64720000,    65.77780000,    65.16920000,    65.20830000,    65.46150000,    66.42130000,    67.27440000,    68.61260000,    69.64780000,    71.02060000,    72.64140000,    74.45120000,    75.34100000,    76.36580000,    76.84450000,    77.97250000,    78.61580000,    80.39330000,    81.68650000,    83.75320000,    84.69500000,    86.67050000,    88.46710000,    91.46700000,    94.10010000,    94.38040000,    101.24330000,    101.87020000,    109.11530000,    106.87570000,    160.76960000,    156.34410000,    152.53520000,    144.10960000,    138.15000000,    128.73000000,    123.64000000,    115.59000000,    111.61000000,    104.89000000,    101.72000000,    97.46000000,    95.78000000,    93.56000000,    92.75000000,    91.30000000,    90.47000000,    90.65000000,    91.91000000,    95.17000000,    97.19000000,    102.00000000,    105.10000000,    111.02000000,    114.30000000,    119.42000000,    121.37000000,    124.77000000,    125.87000000,    127.99000000,    127.52000000,    125.57000000,    124.35000000,    121.05000000,    118.20000000,    113.42000000,    110.80000000,    110.20000000,    110.57000000,    112.03000000,    113.14000000,    114.39000000,    115.69000000,    117.85000000,    119.82000000,    123.53000000,    125.54000000,    128.59000000,    129.77000000,    130.96000000,    131.16000000,    131.34000000,    131.57000000,    132.17000000,    132.45000000,    132.97000000,    133.25000000,    133.24000000,    133.11000000,    132.91000000,    132.78000000,    132.77000000,    132.86000000,    132.61000000,    131.03000000,    128.77000000,    126.99000000,    130.61000000,    135.83000000,    144.68460000,    148.31580000,    151.69230000,    151.69230000,    151.69230000,    151.69380000,    151.69380000,    152.20120000,    152.77540000,    152.94660000,    152.99120000,    152.94660000,    152.96600000,    153.21380000,    154.01160000,    154.56980000,    155.45860000,    155.74640000,    155.94660000,    155.71880000,    155.05930000,    153.92550000,    152.77830000,    151.74030000,    151.11980000,    150.79870000,    150.71340000,    150.59560000,    150.38280000,    149.90300000,    149.12540000,    147.97580000,    146.98170000,    147.87670000,    149.18890000,    151.29340000,    153.69920000,    156.35350000,    158.57340000,    159.98410000,    161.00960000,    162.01820000,    162.83750000,    163.65710000,    164.36290000,    165.05730000,    164.60150000,    162.23300000,    158.78190000,    156.60790000,    156.54120000,    157.16620000,    157.73500000,    158.32710000,    158.86250000,    159.29870000,    158.92710000,    157.45170000,    153.14300000,    145.30770000,    141.89000000,    141.40000000,    142.28650000,    144.07750000,    146.37720000,    148.93380000,    151.09600000,    153.24720000,    154.95920000,    156.54980000,    157.82930000,    159.53770000,    160.82840000,    160.56640000,    159.19020000,    156.56390000,    153.03600000,    148.95840000,    146.66460000,    145.53100000,    145.00780000,    144.74940000,    144.39590000,    143.55770000,    142.42590000,    140.94000000,    140.30000000,    140.41000000,    140.55000000,    140.29000000,    139.67000000,    138.91000000,    138.34000000,    137.16000000,    134.08000000,    127.93000000,    121.67000000,    115.56000000,    113.19000000,    108.80000000,    105.66000000,    102.34000000,    99.41000000,    97.65000000,    98.20000000,    89.68000000,    94.70000000,    95.46000000,    100.06000000,    99.05000000,    99.11000000,    101.07000000,    99.78000000,    101.05000000,    97.05000000,    97.65000000,    97.11000000,    97.12000000,    97.69000000,    98.06000000,    98.76000000,    99.09000000,    98.81000000,    98.09000000,    97.07000000,    95.37000000,    92.75000000,    91.42000000,    93.87000000,    95.51000000,    96.14000000,    97.03000000,    97.84000000,    98.89000000,    100.56000000,    104.72000000,    107.40000000,    107.22000000,    106.97000000,    104.78000000,    96.68000000,    95.07000000,    94.52000000,    94.19000000,    92.88000000,    92.52000000,    92.01000000,    92.30000000,    92.20000000,    91.76000000,    93.33000000,    93.72000000,    94.33000000,    94.55000000,    95.17000000,    94.25000000,    93.57000000,    93.14000000,    94.03000000,    94.03000000,    94.03000000,    94.03000000,    95.47000000,    94.39000000,    93.83000000,    92.91000000,    93.59000000,    93.90000000,    93.69000000,    93.63000000,    93.47000000,    94.10000000,    92.21000000,    92.99000000,    93.35000000,    96.99000000,    103.87000000,    116.01000000,    126.22000000,    130.63000000,    129.02000000,    124.04000000,    120.73000000,    118.62000000,    117.65000000,    116.78000000,    117.72000000,    117.18000000,    120.95000000,    122.10000000,    121.67000000,    120.79000000,    119.87000000,    119.63000000,    119.76000000,    120.57000000,    118.82000000,    118.28000000,    118.03000000,    117.82000000,    117.66000000,    116.14000000,    118.27000000,    118.94000000,    120.79000000,    120.56000000,    120.44000000,    120.93000000,    120.32000000,    120.82000000,    118.55000000,    116.41000000,    115.12000000,    113.27000000,    110.23000000,    105.31000000,    97.56000000,    95.30000000,    93.83000000,    95.80000000,    98.85000000,    102.63000000,    105.36000000,    108.79000000,    111.18000000,    112.85000000,    115.68000000,    119.60000000,    123.42000000,    127.00000000,    130.00000000,    132.89000000,    134.33000000,    135.75000000,    137.18000000,    136.52000000,    131.50000000,    114.20000000,    107.20000000,    101.11000000,    96.68000000,    93.29000000,    93.55000000,    96.10000000,    99.00000000,    101.34000000,    103.57000000,    105.36000000,    108.20000000,    110.38000000,    109.89000000,    108.19000000,    105.42000000,    101.19000000,    105.92000000,    104.88000000,    103.70000000,    108.03000000,    110.38000000,    111.12000000,    108.43000000,    113.05000000,    109.68000000,    111.84000000,    112.16000000,    109.61000000,    108.07000000,    107.54000000,    108.38000000,    109.74000000,    109.78000000,    109.58000000,    106.72000000,    104.58000000,    103.07000000,    100.44000000,    97.62000000,    96.75000000,    96.28000000,    94.87000000,    93.65000000,    94.97000000,    92.22000000,    93.74000000,    94.31000000,    94.25000000,    94.86000000,    97.46000000,    95.10000000,    94.92000000,    93.23000000,    96.26000000,    94.51000000,    92.12000000,    91.65000000,    92.70000000,    94.48000000,    96.07000000,    97.47000000,    97.80000000,    97.05000000,    96.12000000,    95.40000000,    93.34000000,    92.35000000,    92.08000000,    91.83000000,    92.44000000,    91.49000000,    91.06000000,    92.18000000,    93.67000000,    94.86000000,    96.49000000,    98.04000000,    99.87000000,    101.33000000,    101.75000000,    93.19000000,    93.37000000,    92.39000000,    91.50000000,    90.28000000,    90.56000000,    90.52000000,    89.85000000,    90.00000000,    89.50000000,    89.54000000,    89.54000000,    89.51000000,    89.90000000,    89.70000000,    89.80000000,    89.66000000,    89.54000000,    89.50000000,    89.50000000,    89.50000000,    89.50000000,    89.50000000,    89.62000000,    89.50000000,    89.50000000,    89.50000000,    89.50000000,    89.50000000,    89.52000000,    89.72000000,    89.91000000,    89.83000000,    90.51000000,    91.66000000,    92.91000000,    95.15000000,    100.40000000,    112.17000000,    121.82000000,    127.11000000,    129.06000000,    126.49000000,    122.27000000,    119.02000000,    116.66000000,    116.88000000,    116.11000000,    115.73000000,    117.05000000,    117.16000000,    118.28000000,    120.12000000,    119.44000000,    119.21000000,    119.20000000,    119.73000000,    119.11000000,    119.25000000,    119.47000000,    120.27000000,    120.74000000,    120.36000000,    120.12000000,    120.47000000,    120.12000000,    119.86000000,    120.34000000,    120.44000000,    120.67000000,    119.36000000,    116.15000000,    109.06000000,    106.51000000,    104.76000000,    100.52000000,    97.82000000,    93.90000000,    92.56000000,    92.58000000,    92.96000000,    94.02000000,    95.05000000,    94.78000000,    93.35000000,    92.05000000,    93.62000000,    94.68000000,    93.84000000,    93.27000000,    93.72000000,    93.92000000,    94.18000000,    95.41000000,    96.97000000,    100.62000000,    101.10000000,    99.92000000,    97.81000000,    98.68000000,    98.73000000,    97.04000000,    93.98000000,    92.37000000,    92.06000000,    91.78000000,    91.44000000,    92.09000000,    92.76000000,    94.16000000,    95.51000000,    99.02000000,    102.08000000,    106.19000000,    110.27000000,    111.42000000,    113.57000000,    114.14000000,    113.20000000,    115.50000000,    117.15000000,    118.29000000,    117.82000000,    115.64000000,    117.15000000,    116.45000000,    117.33000000,    118.10000000,    117.15000000,    117.37000000,    117.92000000,    114.94000000,    115.47000000,    112.74000000,    109.93000000,    106.17000000,    108.60000000,    106.00000000,    105.25000000,    104.11000000,    106.79000000,    107.47000000,    110.59000000,    115.44000000,    118.47000000,    117.17000000,    113.68000000,    109.82000000,    106.15000000,    103.05000000,    100.98000000,    98.98000000,    97.51000000,    96.28000000,    95.39000000,    94.43000000,    93.75000000,    93.01000000,    92.21000000,    91.70000000,    91.39000000,    91.33000000,    91.24000000,    91.20000000,    90.98000000,    91.15000000,    91.31000000,    91.51000000,    92.41000000,    92.81000000,    92.82000000,    92.80000000,    91.20000000,    90.21000000,    90.06000000,    94.77000000,    99.88000000,    100.67000000,    102.16000000,    99.43000000,    99.30000000,    97.58000000,    96.08000000,    98.82000000,    98.99000000,    96.01000000,    95.95000000,    94.61000000,    92.22000000,    93.09000000,    92.97000000,    92.25000000,    93.02000000,    94.27000000,    92.95000000,    91.72000000,    91.78000000,    92.14000000,    92.92000000,    93.70000000,    92.37000000,    93.06000000,    93.65000000,    93.22000000,    92.22000000,    92.16000000,    90.90000000,    90.87000000,    91.02000000,    92.82000000,    93.79000000,    94.97000000,    95.81000000,    98.60000000,    100.81000000,    105.09000000,    113.56000000,    121.87000000,    128.28000000,    129.20000000,    126.47000000,    123.70000000,    121.11000000,    119.83000000,    119.75000000,    120.52000000,    120.77000000,    121.01000000,    121.57000000,    122.67000000,    122.15000000,    122.27000000,    122.50000000,    123.05000000,    123.12000000,    123.39000000,    123.36000000,    124.10000000,    124.28000000,    124.68000000,    124.90000000,    125.06000000,    126.10000000,    126.55000000,    126.79000000,    126.27000000,    126.14000000,    124.49000000,    122.99000000,    120.96000000,    118.52000000,    115.41000000,    111.58000000,    110.74000000,    109.42000000,    110.32000000,    112.63000000,    115.86000000,    119.46000000,    122.34000000,    125.17000000,    128.47000000,    129.77000000,    131.32000000,    132.93000000,    135.27000000,    137.14000000,    139.10000000,    140.83000000,    142.40830000,    142.02290000,    141.14000000,    142.85320000,    141.23000000,    140.95000000,    137.73000000,    136.79000000,    135.79000000,    135.45000000,    134.40000000,    133.76000000,    134.18000000,    132.64000000,    132.86000000,    134.02000000,    133.50000000,    134.32000000,    135.75000000,    137.90000000,    139.81000000,    142.62110000,    142.70090000,    142.29340000,    141.65000000,    142.18870000,    139.20000000,    140.85000000,    140.72000000,    139.77000000,    141.82000000,    142.63700000,    144.03450000,    145.52000000,    144.74140000,    146.69500000,    144.77170000,    144.57660000,    143.81210000,    141.37000000,    136.88000000,    134.06000000,    130.32000000,    126.04000000,    122.58000000,    117.92000000,    124.42000000,    120.52000000,    120.52000000,    120.52000000,    120.52000000,    120.52000000,    102.10000000,    99.17000000,    97.97000000,    96.86000000,    95.56000000,    94.71000000,    94.73000000,    94.63000000,    95.06000000,    95.35000000,    97.50000000,    100.92000000,    103.23000000,    105.22000000,    -14.65000000
};

#pragma endregion


//Initializing a 3D vector (name = vector_3d )with dimensions (2, 3, 4) and initializing each element with 1
//  vector<vector<vector<int>>> vector_3d(2, vector<vector<int>>(3, vector<int>(4, 1)));

// Storage for images
int32 maxImages = num_samples_mem_allocation; // or any other appropriate value
std::vector<ImagePtr> imageStorage(maxImages);

// Storage for on-the-fly stage motion direction estimation ---------------------------

// Threshold to filter out encoder noise for motion direction estimation
const double MOTION_DIRECTION_ESTIMATION_THRESHOLD = 20e-3;
const double MOTION_DIRECTION_ESTIMATION_camera_offset = 145.0;   // deg
const double MOTION_DIRECTION_ESTIMATION_DeltaTempMaxSwing = 150.0; //deg C 

// Preinitialize variables for motion direction estimation
double delta_x_for_direction_estimation = 0.0;
double delta_y_for_direction_estimation = 0.0;
double motion_magnitude_for_direction_estimation = 0.0;
double estimated_direction_theta_from_encoders = 0.0;
double degrees_to_radians = M_PI / 180.0;
double radians_to_degrees = 180.0 / M_PI;



#pragma endregion

#pragma region deviceFunctions // Device functions and initialization code 

// double generatePRBS(int &state) {
//     // XOR two bits of the state, shift them, and set the new bit
//     int bit = ((state >> 0) ^ (state >> 2)) & 1;
//     state = (state >> 1) | (bit << 15); // Assuming a 16-bit PRBS
//     return (state & 1) ? 2.0 : 0.0; // Generate a PRBS signal with amplitude ±2.0
// }

#pragma region userDef_function_laserRefSmooth

// Parameters
const double start_time = 10.0;   // Start applying at t = 20 sec
const double end_time = 20.0;     // End transition at t = 30 sec
// const double desired_temperature_C = 950.0; // Target temperature
double desired_temperature_C = 950.0; // Target temperature
double start_temp_C = 550.0;
int32 laserPower_index = 0;

const int num_samples_laserRefSmooth = (end_time - start_time) / sample_period_s; // Number of steps

std::vector<double> laserRefTempStartSmooth(num_samples_laserRefSmooth, 0.0);

// Generate a smooth transition using linear interpolation (LERP) or sigmoid
void generateLaserReferenceSignal(double desired_temperature_C, double start_temp_C) {


    double k = 10.0; // Controls how steep the transition is

    for (int i = 0; i < num_samples_laserRefSmooth; i++) {
        double t = static_cast<double>(i) / (num_samples_laserRefSmooth - 1); // Normalize 0 to 1
        double sigmoid = 1.0 / (1.0 + exp(-k * (t - 0.5))); // Sigmoid function
        laserRefTempStartSmooth[i] = start_temp_C + (desired_temperature_C - start_temp_C) * sigmoid; 
    }

}

// Call this function once at startup
// generateLaserReferenceSignal();

#pragma endregion


#pragma region deviceFunction_OptrisCamera
    // There are no known functions eveything is in the header files and libraries.
#pragma endregion

#pragma region deviceFunction_FLIRCamera

// Functions for the FLIR Camera


// Use the following enum and global constant to select whether a software or
// hardware trigger is used.
enum triggerType
{
    SOFTWARE,
    HARDWARE
};

const triggerType chosenTrigger = SOFTWARE;

// This function configures the camera to use a trigger. First, trigger mode is
// set to off in order to select the trigger source. Once the trigger source
// has been selected, trigger mode is then enabled, which has the camera
// capture only a single image upon the execution of the chosen trigger.
int ConfigureTrigger(INodeMap& nodeMap)
{
    int result = 0;

    cout << endl << endl << "*** CONFIGURING TRIGGER ***" << endl << endl;

    cout << "Note that if the application / user software triggers faster than frame time, the trigger may be dropped "
            "/ skipped by the camera."
         << endl
         << "If several frames are needed per trigger, a more reliable alternative for such case, is to use the "
            "multi-frame mode."
         << endl
         << endl;

    if (chosenTrigger == SOFTWARE)
    {
        cout << "Software trigger chosen..." << endl;
    }
    else if (chosenTrigger == HARDWARE)
    {
        cout << "Hardware trigger chosen..." << endl;
    }

    try
    {
        //
        // Ensure trigger mode off
        //
        // *** NOTES ***
        // The trigger must be disabled in order to configure whether the source
        // is software or hardware.
        //
        CEnumerationPtr ptrTriggerMode = nodeMap.GetNode("TriggerMode");
        if (!IsReadable(ptrTriggerMode))
        {
            cout << "Unable to disable trigger mode (node retrieval). Aborting..." << endl;
            return -1;
        }

        CEnumEntryPtr ptrTriggerModeOff = ptrTriggerMode->GetEntryByName("Off");
        if (!IsReadable(ptrTriggerModeOff))
        {
            cout << "Unable to disable trigger mode (enum entry retrieval). Aborting..." << endl;
            return -1;
        }

        ptrTriggerMode->SetIntValue(ptrTriggerModeOff->GetValue());

        cout << "Trigger mode disabled..." << endl;

        //
        // Set TriggerSelector to FrameStart
        //
        // *** NOTES ***
        // For this example, the trigger selector should be set to frame start.
        // This is the default for most cameras.
        //
        CEnumerationPtr ptrTriggerSelector = nodeMap.GetNode("TriggerSelector");
        if (!IsReadable(ptrTriggerSelector) ||
            !IsWritable(ptrTriggerSelector))
        {
            cout << "Unable to get or set trigger selector (node retrieval). Aborting..." << endl;
            return -1;
        }

        CEnumEntryPtr ptrTriggerSelectorFrameStart = ptrTriggerSelector->GetEntryByName("FrameStart");
        if (!IsReadable(ptrTriggerSelectorFrameStart))
        {
            cout << "Unable to get trigger selector (enum entry retrieval). Aborting..." << endl;
            return -1;
        }

        ptrTriggerSelector->SetIntValue(ptrTriggerSelectorFrameStart->GetValue());

        cout << "Trigger selector set to frame start..." << endl;

        //
        // Select trigger source
        //
        // *** NOTES ***
        // The trigger source must be set to hardware or software while trigger
        // mode is off.
        //
        CEnumerationPtr ptrTriggerSource = nodeMap.GetNode("TriggerSource");
        if (!IsReadable(ptrTriggerSource) ||
            !IsWritable(ptrTriggerSource))
        {
            cout << "Unable to get or set trigger mode (node retrieval). Aborting..." << endl;
            return -1;
        }

        if (chosenTrigger == SOFTWARE)
        {
            // Set trigger mode to software
            CEnumEntryPtr ptrTriggerSourceSoftware = ptrTriggerSource->GetEntryByName("Software");
            if (!IsReadable(ptrTriggerSourceSoftware))
            {
                cout << "Unable to set trigger mode (enum entry retrieval). Aborting..." << endl;
                return -1;
            }

            ptrTriggerSource->SetIntValue(ptrTriggerSourceSoftware->GetValue());

            cout << "Trigger source set to software..." << endl;
        }
        else if (chosenTrigger == HARDWARE)
        {
            // Set trigger mode to hardware ('Line0')
            CEnumEntryPtr ptrTriggerSourceHardware = ptrTriggerSource->GetEntryByName("Line0");
            if (!IsReadable(ptrTriggerSourceHardware))
            {
                cout << "Unable to set trigger mode (enum entry retrieval). Aborting..." << endl;
                return -1;
            }

            ptrTriggerSource->SetIntValue(ptrTriggerSourceHardware->GetValue());

            cout << "Trigger source set to hardware..." << endl;
        }

        //
        // Turn trigger mode on
        //
        // *** LATER ***
        // Once the appropriate trigger source has been set, turn trigger mode
        // on in order to retrieve images using the trigger.
        //

        CEnumEntryPtr ptrTriggerModeOn = ptrTriggerMode->GetEntryByName("On");
        if (!IsReadable(ptrTriggerModeOn))
        {
            cout << "Unable to enable trigger mode (enum entry retrieval). Aborting..." << endl;
            return -1;
        }

        ptrTriggerMode->SetIntValue(ptrTriggerModeOn->GetValue());

        // NOTE: Blackfly and Flea3 GEV cameras need 1 second delay after trigger mode is turned on

        cout << "Trigger mode turned back on..." << endl << endl;
    }
    catch (Spinnaker::Exception& e)
    {
        cout << "Error: " << e.what() << endl;
        result = -1;
    }

    return result;
}

// This function retrieves a single image using the trigger. In this example,
// only a single image is captured and made available for acquisition - as such,
// attempting to acquire two images for a single trigger execution would cause
// the example to hang. This is different from other examples, whereby a
// constant stream of images are being captured and made available for image
// acquisition.
int GrabNextImageByTrigger(INodeMap& nodeMap, CameraPtr pCam)
{
    int result = 0;

    try
    {
        //
        // Use trigger to capture image
        //
        // *** NOTES ***
        // The software trigger only feigns being executed by the Enter key;
        // what might not be immediately apparent is that there is not a
        // continuous stream of images being captured; in other examples that
        // acquire images, the camera captures a continuous stream of images.
        // When an image is retrieved, it is plucked from the stream.
        //
        if (chosenTrigger == SOFTWARE)
        {
            // Get user input
            cout << "Press the Enter key to initiate software trigger." << endl;
            getchar();

            // Execute software trigger
            CCommandPtr ptrSoftwareTriggerCommand = nodeMap.GetNode("TriggerSoftware");
            if (!IsWritable(ptrSoftwareTriggerCommand))
            {
                cout << "Unable to execute trigger. Aborting..." << endl;
                return -1;
            }

            ptrSoftwareTriggerCommand->Execute();

            // NOTE: Blackfly and Flea3 GEV cameras need 2 second delay after software trigger
        }
        else if (chosenTrigger == HARDWARE)
        {
            // Execute hardware trigger
            cout << "Use the hardware to trigger image acquisition." << endl;
        }
    }
    catch (Spinnaker::Exception& e)
    {
        cout << "Error: " << e.what() << endl;
        result = -1;
    }

    return result;
}

// This function returns the camera to a normal state by turning off trigger
// mode.
int ResetTrigger(INodeMap& nodeMap)
{
    int result = 0;

    try
    {
        //
        // Turn trigger mode back off
        //
        // *** NOTES ***
        // Once all images have been captured, turn trigger mode back off to
        // restore the camera to a clean state.
        //
        CEnumerationPtr ptrTriggerMode = nodeMap.GetNode("TriggerMode");
        if (!IsReadable(ptrTriggerMode))
        {
            cout << "Unable to disable trigger mode (node retrieval). Non-fatal error..." << endl;
            return -1;
        }

        CEnumEntryPtr ptrTriggerModeOff = ptrTriggerMode->GetEntryByName("Off");
        if (!IsReadable(ptrTriggerModeOff))
        {
            cout << "Unable to disable trigger mode (enum entry retrieval). Non-fatal error..." << endl;
            return -1;
        }

        ptrTriggerMode->SetIntValue(ptrTriggerModeOff->GetValue());

        cout << "Trigger mode disabled..." << endl << endl;
    }
    catch (Spinnaker::Exception& e)
    {
        cout << "Error: " << e.what() << endl;
        result = -1;
    }

    return result;
}

// This function prints the device information of the camera from the transport
// layer; please see NodeMapInfo example for more in-depth comments on printing
// device information from the nodemap.
int PrintDeviceInfo(INodeMap& nodeMap)
{
    int result = 0;

    cout << endl << "*** DEVICE INFORMATION ***" << endl << endl;

    try
    {
        FeatureList_t features;
        CCategoryPtr category = nodeMap.GetNode("DeviceInformation");
        if (IsReadable(category))
        {
            category->GetFeatures(features);

            FeatureList_t::const_iterator it;
            for (it = features.begin(); it != features.end(); ++it)
            {
                CNodePtr pfeatureNode = *it;
                cout << pfeatureNode->GetName() << " : ";
                CValuePtr pValue = (CValuePtr)pfeatureNode;
                cout << (IsReadable(pValue) ? pValue->ToString() : "Node not readable");
                cout << endl;
            }
        }
        else
        {
            cout << "Device control information not readable." << endl;
        }
    }
    catch (Spinnaker::Exception& e)
    {
        cout << "Error: " << e.what() << endl;
        result = -1;
    }

    return result;
}

// This function acquires and saves 10 images from a device; please see
// Acquisition example for more in-depth comments on acquiring images.
int AcquireImages(CameraPtr pCam, INodeMap& nodeMap, INodeMap& nodeMapTLDevice)
{
    int result = 0;

    cout << endl << "*** IMAGE ACQUISITION ***" << endl << endl;

    try
    {
        // Set acquisition mode to continuous
        CEnumerationPtr ptrAcquisitionMode = nodeMap.GetNode("AcquisitionMode");
        if (!IsReadable(ptrAcquisitionMode) ||
            !IsWritable(ptrAcquisitionMode))
        {
            cout << "Unable to get or set acquisition mode to continuous (node retrieval). Aborting..." << endl << endl;
            return -1;
        }

        CEnumEntryPtr ptrAcquisitionModeContinuous = ptrAcquisitionMode->GetEntryByName("Continuous");
        if (!IsReadable(ptrAcquisitionModeContinuous))
        {
            cout << "Unable to get acquisition mode to continuous (entry 'continuous' retrieval). Aborting..." << endl
                 << endl;
            return -1;
        }

        int64_t acquisitionModeContinuous = ptrAcquisitionModeContinuous->GetValue();

        ptrAcquisitionMode->SetIntValue(acquisitionModeContinuous);

        cout << "Acquisition mode set to continuous..." << endl;

        // Begin acquiring images
        pCam->BeginAcquisition();

        cout << "Acquiring images..." << endl;

        // Retrieve device serial number for filename
        gcstring deviceSerialNumber("");

        CStringPtr ptrStringSerial = nodeMapTLDevice.GetNode("DeviceSerialNumber");
        if (IsReadable(ptrStringSerial))
        {
            deviceSerialNumber = ptrStringSerial->GetValue();

            cout << "Device serial number retrieved as " << deviceSerialNumber << "..." << endl;
        }
        cout << endl;

        // Retrieve, convert, and save images
        const int unsigned k_numImages = 10;

        //
        // Create ImageProcessor instance for post processing images
        //
        ImageProcessor processor;

        //
        // Set default image processor color processing method
        //
        // *** NOTES ***
        // By default, if no specific color processing algorithm is set, the image
        // processor will default to NEAREST_NEIGHBOR method.
        //
        processor.SetColorProcessing(SPINNAKER_COLOR_PROCESSING_ALGORITHM_HQ_LINEAR);

        for (unsigned int imageCnt = 0; imageCnt < k_numImages; imageCnt++)
        {
            try
            {
                // Retrieve the next image from the trigger
                result = result | GrabNextImageByTrigger(nodeMap, pCam);

                // Retrieve the next received image
                ImagePtr pResultImage = pCam->GetNextImage(sample_period);

                if (pResultImage->IsIncomplete())
                {
                    cout << "Image incomplete with image status " << pResultImage->GetImageStatus() << "..." << endl
                         << endl;
                }
                else
                {
                    // Print image information
                    cout << "Grabbed image " << imageCnt << ", width = " << pResultImage->GetWidth()
                         << ", height = " << pResultImage->GetHeight() << endl;

                    // Convert image to mono 8
                    ImagePtr convertedImage = processor.Convert(pResultImage, PixelFormat_Mono8);

                    // Create a unique filename
                    ostringstream filename;

                    filename << "Trigger-";
                    if (deviceSerialNumber != "")
                    {
                        filename << deviceSerialNumber.c_str() << "-";
                    }
                    filename << imageCnt << ".jpg";

                    // Save image
                    convertedImage->Save(filename.str().c_str());

                    cout << "Image saved at " << filename.str() << endl;
                }

                // Release image
                pResultImage->Release();

                cout << endl;
            }
            catch (Spinnaker::Exception& e)
            {
                cout << "Error: " << e.what() << endl;
                result = -1;
            }
        }

        // End acquisition
        pCam->EndAcquisition();
    }
    catch (Spinnaker::Exception& e)
    {
        cout << "Error: " << e.what() << endl;
        result = -1;
    }

    return result;
}

// This function acts as the body of the example; please see NodeMapInfo example
// for more in-depth comments on setting up cameras.
int RunSingleCamera(CameraPtr pCam)
{
    int result = 0;
    int err = 0;

    try
    {
        // Retrieve TL device nodemap and print device information
        INodeMap& nodeMapTLDevice = pCam->GetTLDeviceNodeMap();

        result = PrintDeviceInfo(nodeMapTLDevice);

        // Initialize camera
        pCam->Init();

        // Retrieve GenICam nodemap
        INodeMap& nodeMap = pCam->GetNodeMap();

        // Configure trigger
        err = ConfigureTrigger(nodeMap);
        if (err < 0)
        {
            return err;
        }

        // Acquire images
        result = result | AcquireImages(pCam, nodeMap, nodeMapTLDevice);

        // Reset trigger
        result = result | ResetTrigger(nodeMap);

        // Deinitialize camera
        pCam->DeInit();
    }
    catch (Spinnaker::Exception& e)
    {
        cout << "Error: " << e.what() << endl;
        result = -1;
    }

    return result;
}


// Functions for the FLIR Camera END 

#pragma endregion

#pragma region deviceFunctions_NIDAQ_dev_fx

#define DAQmxErrChk(functionCall) if( DAQmxFailed(error=(functionCall)) ) goto Error; else
// #define DAQmxErrChk(functionCall) if( DAQmxFailed(error=(static_cast<int>(functionCall))) ) goto Error; else

#pragma endregion

#pragma region deviceFunctions_RTLoop

static void inc_period(struct period_info *pinfo) // Function to increment the period
{
        pinfo->next_period.tv_nsec += pinfo->period_ns; // Add the period duration to the current time's nanoseconds
 
        while (pinfo->next_period.tv_nsec >= 1000000000) { // Check for nanosecond overflow
                /* timespec nsec overflow */
                pinfo->next_period.tv_sec++; // Increment seconds if overflow occurs
                pinfo->next_period.tv_nsec -= 1000000000; // Adjust nanoseconds after overflow
        }
}
 
int total_loop_iterations = total_time*1000/sample_period;

// Signum Function specifically for float
int signum(float val) {
    return (0.0f < val) - (val < 0.0f);
}

static void periodic_task_init(struct period_info *pinfo) // Function to initialize the periodic task
{
        /* for simplicity, softcoding a 100 ms period */
        pinfo->period_ns = sample_period*1000000; // Set the period duration
 
        clock_gettime(CLOCK_MONOTONIC, &(pinfo->next_period)); // Get the current time as the starting point
}

 
static void do_rt_task(TaskHandle taskHandle, float64 *motorAngle, int32 *read) // Function to perform the real-time task
{

      // Passing objects around is very difficult especially when SDKs are involved.  

}
 
static void wait_rest_of_period(struct period_info *pinfo) // Function to wait for the rest of the period
{
        inc_period(pinfo); // Increment the period to the next cycle

        // printf("Waiting for next period: %ld sec, %ld nsec\n", 
        //    pinfo->next_period.tv_sec, pinfo->next_period.tv_nsec);
        /* for simplicity, ignoring possibilities of signal wakes */
        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &pinfo->next_period, NULL); // Sleep until the next period
        // int res = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &pinfo->next_period, NULL);
    
        // if (res != 0) {
        //         printf("clock_nanosleep returned non-zero result: %d\n", res);
        // }
}
#pragma endregion

#pragma region deviceFunctions_LineScanner // Device functions for the lineScanner

        //     gint32 GetProfilesCallback(int64_t loop_counter)
        // {
        //     gint32 ret = 0;
        //     profile_count = 0;

        //     std::vector<double> value_x, value_z;
        //     needed_profile_count = 1;

        //     if(debug_lines)
        //     std::cout << "Get profiles via callback" << std::endl;

        //     profile_buffer.resize(resolution * 64);

        //     value_x.resize(resolution);
        //     value_z.resize(resolution);

        //     CInterfaceLLT::ResetEvent(event);

        //     // setup transfer of multiple profiles
        //     if ((ret = hLLT->TransferProfiles(NORMAL_TRANSFER, true)) < GENERAL_FUNCTION_OK) {
        //         std::cout << "Error in profile transfer! " << ret << "" << std::endl;
        //         return ret;
        //     }

        //     if(debug_lines)
        //     std::cout << "Start acquisition of profiles" << std::endl;
        //     if (CInterfaceLLT::WaitForSingleObject(event, 5000) != WAIT_OBJECT_0) {
        //         std::cout << "Timeout!" << std::endl;
        //     }

        //     // stop transfer
        //     if ((ret = hLLT->TransferProfiles(NORMAL_TRANSFER, false)) < GENERAL_FUNCTION_OK) {
        //         std::cout << "Error while stopping transmission!" << std::endl;
        //         return ret;
        //     }

        //     if (profile_count == needed_profile_count && profile_data_size == profile_buffer.size()) {
        //         if(debug_lines)
        //         std::cout << "1: All " << profile_count << " profiles reveived with correct size" << std::endl;
        //     } else {
        //         std::cout << "1: Wrong profile count: " << profile_count << "" << std::endl;
        //         return ERROR_PROFTRANS_WRONG_DATA_SIZE;
        //     }

        //     // display example points
        //     if ((ret = CInterfaceLLT::ConvertProfile2Values(&profile_buffer[0], profile_buffer.size(), resolution, PROFILE, llt_type, 0,
        //                                                     NULL, NULL, NULL, &value_x[0], &value_z[0], NULL, NULL)) !=
        //         (CONVERT_X | CONVERT_Z)) {
        //         std::cout << "Error while extracting profiles" << std::endl;
        //         return ret;
        //     }
            
        //     StoreProfilesAndTimestamp(&value_x[0], &value_z[0], resolution, &profile_buffer[(resolution * 64) - 16], loop_counter);

        //     // DisplayProfiles(&value_x[0], &value_z[0], resolution);
        //     // DisplayTimestamp(&profile_buffer[(resolution * 64) - 16]);

        //     return GENERAL_FUNCTION_OK;
        // }

        // void NewProfile(const void *data, size_t data_size, gpointer user_data)
        // {
        //     if (data_size == profile_buffer.size() && profile_count < needed_profile_count) {
        //         profile_data_size = data_size;
        //         memcpy(&profile_buffer[0], data, data_size);
        //         profile_count++;

        //         CInterfaceLLT::Timestamp2TimeAndCount(&profile_buffer[(resolution * 64) - 16], &shutter_closed, &shutter_opened,
        //                                             &profile_counter, NULL);
        //         if (first_trans > 3) {
        //             if ((profile_counter != old_profile_counter + 1) ||
        //                 !(profile_counter == 0 && old_profile_counter == 16777215))
        //                 lost_profiles += profile_counter - old_profile_counter - 1;
        //         } else {
        //             first_trans++;
        //         }
        //         old_profile_counter = profile_counter;
        //         std::cout << "PC: " << profile_counter << " LP: " << lost_profiles << " \r";
        //     }
        //     if (profile_count >= needed_profile_count) {
        //         set_event(event);
        //     }
        // }

        // void ControlLostCallback(gpointer user_data)
        // {
        //     // control of the device is lost. Display a message and exit!
        //     std::cout << "Control lost" << std::endl;
        //     exit(0);
        // }

        // void DisplayProfiles(double *x, double *z, guint32 resolution)
        // {
        //     for (guint32 i = 0; i < resolution; i++) {
        //         std::cout << "\rX: " << x[i] << "  Z: " << z[i] ;
        //         usleep(1250);
        //     }
        //     std::cout << std::endl;

        //     std::ofstream csv_file("profiles_data_4_screwspray.csv", std::ios::out | std::ios::app); // Open file in append mode

        //     if (!csv_file.is_open()) {
        //         std::cerr << "Error opening profiles_data.csv for writing!" << std::endl;
        //         return;
        //     }

        //     // Write headers if the file is empty (only on first call)
        //     if (csv_file.tellp() == 0) {
        //         csv_file << "X, Z" << std::endl;
        //     }

        //     // Write profile data
        //     for (guint32 i = 0; i < resolution; i++) {
        //         csv_file << x[i] << "," << z[i] << std::endl;
        //     }

        //     csv_file.close(); // Close the file
        //     std::cout << "Profiles data saved to profiles_data.csv" << std::endl;

        // }

        // void DisplayTimestamp(guchar *timestamp)
        // {
        //     double shutter_open = 0.0, shutter_close = 0.0;
        //     guint32 profile_count = 0;

        //     CInterfaceLLT::Timestamp2TimeAndCount(&timestamp[0], &shutter_open, &shutter_close, &profile_count, NULL);

        //     std::cout.precision(8);
        //     std::cout << "Profile Count: " << profile_count << " ShutterOpen: " << shutter_open
        //             << " ShutterClose: " << shutter_close << std::endl;
        //     std::cout.precision(6);
        // }

        // void StoreProfilesAndTimestamp(double *x, double *z, guint32 resolution, guchar *timestamp, int64_t loop_counter)
        //     {
        //         std::cout<<"\n loop_counter"<<loop_counter<<"\n";
    
        //         if (loop_counter >= num_samples_mem_allocation) {
        //             std::cerr << "Profile index out of bounds!" << std::endl;
        //             return;
        //         }

        //         // Store profile data
        //         for (int64_t i = 0; i < resolution; i++) {
        //             lineScanData_profileX[loop_counter][i] = static_cast<float64>(x[i]);
        //             lineScanData_profileZ[loop_counter][i] = static_cast<float64>(z[i]);
        //         }

        //         // Store timestamp
        //         double shutter_open = 0.0, shutter_close = 0.0;
        //         guint32 profile_count = 0;

        //         CInterfaceLLT::Timestamp2TimeAndCount(&timestamp[0], &shutter_open, &shutter_close, &profile_count, NULL);

        //         lineScanData_timestamp[loop_counter][0] = static_cast<float64>(shutter_open);
        //     }

#pragma endregion

#pragma region userDefinedFunctions_analog2Phy

    double convertPDVoltToFbkWatt(double FbkLaserPower_PD_Volt) 
    {
        // Point where piecewise function splits
        const double pd_volt_split = 0.0555;

        // Parameters for the linear model
        const double intercept = 0.187185512046098;
        const double slope = 123.2246973800353;

        // Output variable
        double FeedbackLaserPower_GentecPowerMeterWatt = 0.0;

        // Condition 1: Set values for voltages less than 0.0555
        if (FbkLaserPower_PD_Volt < pd_volt_split) {
            FeedbackLaserPower_GentecPowerMeterWatt = -0.008;
        }
        // Condition 2: Calculate values for voltages greater than or equal to 0.0555
        else {
            FeedbackLaserPower_GentecPowerMeterWatt = intercept + slope * FbkLaserPower_PD_Volt;
        }

        FeedbackLaserPower_GentecPowerMeterWatt = optical_efficiency * FeedbackLaserPower_GentecPowerMeterWatt;
        return FeedbackLaserPower_GentecPowerMeterWatt;
    }

    double convertCmdWattToSetPointVolt(double watt) 
    {
        // Point where piecewise function splits
        double setpoint_watt_split = 9.9;

        double setpoint_volt = 0.0;
        // Adjust watt according to optical efficiency
        watt = watt / optical_efficiency;

        if(watt >= maxlimit_laserpower_watt)
        {
            watt = maxlimit_laserpower_watt;
        }
        else if(watt <= minlimit_laserpower_watt)
        {
            watt = minlimit_laserpower_watt;
        }
        else if(watt<maxlimit_laserpower_watt || watt>minlimit_laserpower_watt)
        {
            // Correct range do nothing
        }
        else
        {
            watt = 0;
        }

        // Parameters for the linear model
        double intercept = 0.816729342412847;
        double slope = 0.017074905986381;

        // Compute the setpoint voltage based on the adjusted watt
        if (watt < setpoint_watt_split) {
            setpoint_volt = 0.0;
            return setpoint_volt;  // Set voltage to zero if the adjusted watt is less than the split
        } else {
            setpoint_volt =  intercept + slope * watt;  // Calculate voltage using the linear model
            return setpoint_volt;
        }

    }

    double convertSetPointVoltToCmdWatt(double volt ) 
    {

        // Parameters for the inverse linear model
        double intercept = 0.816729342412847;
        double slope = 0.017074905986381;
        
        // Point where piecewise function splits
        double setpoint_watt_split = 9.9;

        if (volt == 0.0) {
            // If the voltage is zero, it could either be because the watt was less than the split point or it was exactly zero
            // This ambiguity means we cannot definitively return a specific watt value, but we should return the minimum valid watt
            return minlimit_laserpower_watt;
        } else {
            // Calculate the wattage from the voltage using the linear model equation: volt = intercept + slope * watt
            double watt = (volt - intercept) / slope;

            // After calculating, we need to adjust the wattage by the optical efficiency
            watt *= optical_efficiency;

            // We also need to ensure that the wattage lies within the specified limits
            watt = std::max(watt, minlimit_laserpower_watt);
            watt = std::min(watt, maxlimit_laserpower_watt);

            return watt;
        }
    }

#pragma endregion

#pragma region deviceFunctions_Aerotech

        void connectToController();
        void disconnectFromController();
        void startController();
        void stopController();
        void enableAxis(int32_t axis);
        void disableAxis(int32_t axis);
        void homeAxis(int32_t axis);
        void abortAxis(int32_t axis);
        void showAxisStatus(int32_t axis);
        void moveAxisLinear(int32_t axis, double distance, double speed);
        void runProgram(const char* aeroscriptProgramPath);
        void showProgramStatus();
        void stopProgram();
        void getGlobalInteger(int32_t index);
        void setGlobalInteger(int32_t index, int64_t newValue);
        void showAxisParameters(int32_t axis);
        void printHelp();
        void printError();

        // Global controller handle
        Automation1Controller controller = NULL;

                void connectToController()
        {
            // Make sure we aren't connected before trying to do anything.
            if (controller)
            {
                printf("Already connected\n");
                return;
            }

            // Calling Automation1_Connect(&controller) will connect to the controller installed on the local machine. If 
            // we wanted to connect to a controller installed on a different machine with the IP address 192.168.1.15, 
            // we could instead call Automation1_ConnectWithHost("192.168.1.15", &controller).
            //
            // Connecting to the controller will not change its running state, meaning that we might have to also
            // call Automation1_Controller_Start(controller) on our controller variable before we can run AeroScript programs
            // or perform motion. We must start the controller before using most of the functions in the C API. See the 
            // startController(controller) function in this source file for more information on starting the controller.
            //
            // To avoid leaking memory, be sure to call Automation1_Disconnect(controller) before quitting. See 
            // disconnectFromController(controller) for more information.
            //if (!Automation1_Connect(&controller))
            if (!Automation1_ConnectWithHost("192.168.7.1", &controller))
            {
                printError();
                return;
            }

            printf("Connected to Automation1 controller\n");
        }

        /// <summary>
        /// Disconnects from the Automation1 controller.
        /// </summary>
        void disconnectFromController()
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("Already disconnected\n");
                return;
            }

            // Disconnecting from a controller will not change its running state, meaning that the controller
            // might still be running after we disconnect. Call Automation1_Controller_Stop(controller) before disconnecting 
            // to stop the controller from running AeroScript programs or performing motion. See the stopController(controller) 
            // function in this source file for more information. Use this function when your application no longer needs to interact 
            // with the controller but you want the controller to continue running.
            //
            // Calling Automation1_Disconnect(controller) frees memory associated with the controller handle.
            if (!Automation1_Disconnect(controller))
            {
                printError();
            }

            controller = NULL;
            printf("Disconnected from Automation1 controller\n");
        }

        /// <summary>
        /// Starts the Automation1 controller.
        /// </summary>
        void startController()
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before you can start it\n");
                return;
            }

            // The act of connecting to the controller on its own will not change the running state of the controller
            // so we have to explicitly start it by calling Automation1_Controller_Start(controller). We could check 
            // Automation1_Controller_IsRunning(controller) to see if the controller is already running, but since 
            // Automation1_Controller_Start(controller) will just do nothing if the controller is already running we 
            // can call it regardless. We must start the controller before calling any other C API functionality.
            if (!Automation1_Controller_Start(controller))
            {
                printError();
                return;
            }

            printf("Controller started\n");
        }

        /// <summary>
        /// Stops the Automation1 controller.
        /// </summary>
        void stopController()
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before you can stop it\n");
                return;
            }

            // Calling Automation1_Controller_Stop(controller) will stop the Automation1 controller but not disconnect us. 
            // We could check Automation1_Controller_IsRunning(controller) to see if the controller is already running, 
            // but since Automation1_Controller_Stop(controller) will just do nothing if the controller is already running 
            // we can call it regardless.
            if (!Automation1_Controller_Stop(controller))
            {
                printError();
                return;
            }

            printf("Controller stopped\n");
        }

        /// <summary>
        /// Enables an axis.
        /// </summary>
        /// <param name="axis">The index of the axis to enable.</param>
        void enableAxis(int32_t axis)
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before enabling an axis\n");
                return;
            }

            // We can enable an axis using the Automation1_Command_Enable(controller, taskIndex, axes, axesLength) 
            // in the Automation1Command.h header. The Automation1Command.h header provides access to many of the AeroScript 
            // commands that are used to perform actions on the controller. This function accepts an array but we can give it a single
            // value by passing it by-reference and hardcoding the array length to "1".
            // You can also enable multiple axes at once.
            //
            // If an error occurs while executing a command, like if the controller is not started or an axis fault
            // has occurred, the error can be accessed via functionality provided in the Automation1Error.h header file.
            // See the function printError() for more information.
            if (!Automation1_Command_Enable(controller, 1, &axis, 1))
            {
                printError();
                return;
            }

            printf("Axis %d enabled\n", axis);
        }

        /// <summary>
        /// Disables an axis.
        /// </summary>
        /// <param name="axis">The index of the axis to disable.</param>
        void disableAxis(int32_t axis)
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before disabling an axis\n");
                return;
            }

            // We can disable an axis using the Automation1_Command_Disable(controller, axes, axesLength) function 
            // in the Automation1Command.h header. The Automation1Command.h header provides access to many of the AeroScript 
            // commands that are used to perform actions on the controller. This function accepts arrays but we can give it a single
            // value by passing it by-reference and hardcoding the array length to "1".
            // You can also disable multiple axes at once.
            //
            // If an error occurs while executing a command, like if the controller is not started or an axis fault
            // has occurred, the error can be accessed via functionality provided in the Automation1Error.h header file.
            // See the function printError() for more information.
            if (!Automation1_Command_Disable(controller, &axis, 1))
            {
                printError();
                return;
            }

            printf("Axis %d disabled\n", axis);
        }

        /// <summary>
        /// Homes an axis.
        /// </summary>
        /// <param name="axis">The index of the axis to home.</param>
        void homeAxis(int32_t axis)
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before homing an axis\n");
                return;
            }

            // We can home an axis using the Automation1_Command_Home(controller, taskIndex, axes, axesLength) function
            // in the Automation1Command.h header. The Automation1Command.h header provides access to many of the AeroScript 
            // commands that are used to perform actions on the controller. This function accepts an array but we can give it a single
            // value by passing it by-reference and hardcoding the array length to "1".
            // You can also home multiple axes at once.
            //
            // If an error occurs while executing a command, like if the controller is not started or an axis fault
            // has occurred, the error can be accessed via functionality provided in the Automation1Error.h header file.
            // See the function printError() for more information.
            if (!Automation1_Command_Home(controller, 1, &axis, 1))
            {
                printError();
                return;
            }

            printf("Axis %d homed\n", axis);
        }

        /// <summary>
        /// Aborts motion on an axis.
        /// </summary>
        /// <param name="axis">The index of the axis to abort motion on.</param>
        void abortAxis(int32_t axis)
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before aborting\n");
                return;
            }

            // We can abort motion on an axis using theAutomation1_Command_Abort(controller, axes, axesLength) function 
            // in the Automation1Command.h header. The Automation1Command.h header provides access to many of the AeroScript 
            // commands that are used to perform actions on the controller. This function accepts an array but we can give it a single
            // value by passing it by-reference and hardcoding the array length to "1".
            // You can also abort multiple axes at once.
            //
            // If an error occurs while executing a command, like if the controller is not started or an axis fault
            // has occurred, the error can be accessed via functionality provided in the Automation1Error.h header file.
            // See the function printError() for more information.
            if (!Automation1_Command_Abort(controller, &axis, 1))
            {
                printError();
                return;
            }

            printf("Motion aborted on axis %d\n", axis);
        }

        /// <summary>
        /// Gets common and important informaiton about an axis.
        /// </summary>
        /// <param name="axis">The index of the axis to get information about.</param>
        void showAxisStatus(int32_t axis)
        {
            Automation1StatusConfig statusConfig;
            double result[3];
            bool isEnabled;
            bool isHomed;
            bool calibrationEnabled1D;
            bool calibrationEnabled2D;

            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before getting an axis's status.\n");
                return;
            }

            // We can get information about the current state of the controller, tasks, and axes via status items. To do so, we must first
            // specify the items we want to query by creating an Automation1StatusConfig struct. We then add each status item to the axis 
            // category using the Automation1_StatusConfig_AddAxisStatusItem(statusConfig, axis, axisStatusItem, argument) function. To 
            // actually get the values of these items, we call GetStatusItem(statusConfig), which populates an array of doubles with the
            // requested values.
            Automation1_StatusConfig_Create(&statusConfig);
            // Status items are defined in enums in the C API. ProgramPosition is the position specified in program-space, before being
            // transformed and sent to the drive. See the Controller Motion Signals help file topic for more details.
            Automation1_StatusConfig_AddAxisStatusItem(statusConfig, axis, Automation1AxisStatusItem_ProgramPositionFeedback, 0);
            // DriveStatus is a series of bits that can be masked. We will use it to get the axis enabled bit.
            Automation1_StatusConfig_AddAxisStatusItem(statusConfig, axis, Automation1AxisStatusItem_DriveStatus, 0);
            // AxisStatus is another series of bits that can be masked. We will use it to get the axis homed bit, calibration enabled 1D bit,
            // and calibration enabled 2D bit. In this case, homed indicates whether or not the axis in question has been homed since the last
            // controller reset. The calibration bits indicate if the axis is currently calibrated.
            Automation1_StatusConfig_AddAxisStatusItem(statusConfig, axis, Automation1AxisStatusItem_AxisStatus, 0);
            // If we fail to get all status items, we should not use the results. Instead we should free up the memory used by the statusConfig
            // and return.
            if (!Automation1_Status_GetResults(controller, statusConfig, result, 3))
            {
                printf("Failed to get axis %d status\n", axis);
                printError();
                Automation1_StatusConfig_Destroy(statusConfig);
                return;
            }

            printf("Axis %d Status\n", axis);
            printf("--------------\n");

            // ProgramPosition is acquired directly as a double, which is what we need.
            printf("Position: %lf\n", result[0]);

            // DriveStatus is a series of status bits that can be masked to get various information about the state of the drive.
            // It is acquired as a double, but we need to interperet it as a series of maskable bits. To do so, we cast it to 
            // a 64-bit integer. We next apply the "Enabled" mask from the enum and check if the result equals the mask to 
            // determine if the drive axis is enabled.
            isEnabled = (Automation1DriveStatus_Enabled & (int64_t)result[1]) == Automation1DriveStatus_Enabled;
            printf("Enabled: %s\n", isEnabled ? "true" : "false");

            // AxisStatus is similar to DriveStatus in that it can be masked to get information about the state of the axis.
            // It is also acquired as a double, but we again need to interperet it as a series of maskable bits. To do so, we repeat
            // the process outlined for DriveStatus with AxisStatus.
            isHomed = (Automation1AxisStatus_Homed & (int64_t)result[2]) == Automation1AxisStatus_Homed;
            printf("Homed: %s\n", isHomed ? "true" : "false");

            // AxisStatus also contains status bits relating to the calibration state of the axis. To get these, we simply need to 
            // apply different masks and "or" the results.
            calibrationEnabled1D = (Automation1AxisStatus_CalibrationEnabled1D & (int64_t)result[2]) == Automation1AxisStatus_CalibrationEnabled1D;
            calibrationEnabled2D = (Automation1AxisStatus_CalibrationEnabled2D & (int64_t)result[2]) == Automation1AxisStatus_CalibrationEnabled2D;
            printf("Calibration State: %s\n", (calibrationEnabled1D || calibrationEnabled2D) ? "true" : "false");

            // Destorying the statusConfig frees up any memory associated with it.
            Automation1_StatusConfig_Destroy(statusConfig);
        }

        /// <summary>
        /// Executes a linear move on an axis.
        /// </summary>
        /// <param name="axis">The index of the axis to move.</param>
        /// <param name="distance">The distance to move the axis.</param>
        /// <param name="speed">The speed at which to move the axis.</param>
        void moveAxisLinear(int32_t axis, double distance, double speed)
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before moving an axis\n");
                return;
            }

            // The Automation1_Command_MoveLinear(controller, taskIndex, axes, axesLength, distances, distancesLength, speed) 
            // function will not return until the move is complete.  This function accepts arrays but we can give it a single
            // value by passing it by-reference and hardcoding the array length to "1".
            // You can also move multiple axes at once.
            // 
            // We can keep this application responsive during the move if we do the move on a background thread.
            // You should be familiar with multi-threaded programming before doing this.
            printf("Moving axis %d\n", axis);
            if (!Automation1_Command_MoveLinear(controller, 1, &axis, 1, &distance, 1, speed))
            {
                printError();
                return;
            }

            printf("Move complete\n");
        }

        /// <summary>
        /// Runs an AeroScript program on the Automation1 controller.
        /// </summary>
        /// <param name="aeroscriptProgramPath">The path to the .ascript file to run.</param>
        void runProgram(const char* aeroscriptProgramPath)
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before running an AeroScript program\n");
                return;
            }

            // When we call Automation1_Task_ProgramRun(controller, taskIndex, aeroscriptProgramPath), it will 
            // load the program on the controller task and begin execution, but it will not wait for the program
            // to complete before returning. The AeroScript source file will be compiled before running. If there
            // is a compile error, this function will return false and the error can be acquired via the functionality
            // provided via the Automation1Error.h header (see printError() in this file for more details). We can use
            // the functionality from the Automation1Task.h header to check on the status of our program as it runs, 
            // and to find out when it completes.
            printf("Starting AeroScript program\n");
            if (!Automation1_Task_ProgramRun(controller, 1, aeroscriptProgramPath))
            {
                printError();
                return;
            }
        }

        /// <summary>
        /// Shows the status of the currently running AeroScript program.
        /// </summary>
        void showProgramStatus()
        {
            Automation1TaskStatus taskStatus[2];

            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before getting an AeroScript program's status\n");
                return;
            }

            // We can check the state of the task we are running the AeroScript program on (Task 1 in this example)
            // to find out the status of our running AeroScript program. We can check this task state regularly
            // to track our AeroScript program if it runs, make sure no errors occur, etc.
            // Calling Automation1_Task_GetStatus(controller, taskStatus, taskStatusLength) gets a moment in time for 
            // the first taskStatusLength number of tasks on the controller. To get new status you must access the 
            // Status property again.
            if (!Automation1_Task_GetStatus(controller, taskStatus, 2))
            {
                printError();
                return;
            }
            switch (taskStatus[1].TaskState)
            {
            case Automation1TaskState_Error:
                printf("An AeroScript error occurred: %s\n", taskStatus[1].ErrorMessage);
                break;
            case Automation1TaskState_Idle:
                printf("No AeroScript program is loaded or running\n");
                break;
            case Automation1TaskState_ProgramReady:
                printf("The AeroScript program has not started yet\n");
                break;
            case Automation1TaskState_ProgramRunning:
                printf("The AeroScript program is running\n");
                break;
            case Automation1TaskState_ProgramPaused:
                printf("The AeroScript program is paused\n");
                break;
            case Automation1TaskState_ProgramComplete:
                printf("The AeroScript program has completed\n");
                break;
                // We should not encounter these task states in this example program.
            case Automation1TaskState_ProgramFeedhold:
            case Automation1TaskState_Inactive:
            case Automation1TaskState_Unavailable:
            case Automation1TaskState_QueueRunning:
            case Automation1TaskState_QueuePaused:
            default:
                break;
            }
        }

        /// <summary>
        /// Stops the currently running AeroScript program.
        /// </summary>
        void stopProgram()
        {
            // Make sure we are connected before trying to do anything.
            if (!controller)
            {
                printf("You must connect to the controller before stopping a program\n");
                return;
            }

            // To stop a running AeroScript program, we stop the controller task it is running on (Task 1 in this example)
            // The call to Automation1_Task_ProgramStop(controller, taskIndex, millisecondTimeout) will terminate the 
            // program and wait for it to stop (or for the timeout to trigger) before returning.
            if (!Automation1_Task_ProgramStop(controller, 1, 500))
            {
                printError();
                return;
            }

            printf("Program stopped\n");
        }

        void getGlobalInteger(int32_t index) {
            int64_t integerOut; // Proper data type as required by API

            // Make sure we are connected before trying to do anything.
            if (!controller) {
                printf("You must connect to the controller before accessing a global integer\n");
                return;
            }

            // Use the API with int64_t as specified
            if (!Automation1_Variables_GetGlobalIntegers(controller, index, &integerOut, 1)) {
                printError();
                return;
            }

            // Use PRId64 to print int64_t types
            printf("$iglobal[%d] is %" PRId64 "\n", index, integerOut);
        }

        void setGlobalInteger(int32_t index, int64_t newValue) { // Again, using int64_t

            // Make sure we are connected before trying to do anything.
            if (!controller) {
                printf("You must connect to the controller before setting a global integer\n");
                return;
            }

            // Use the API with int64_t as specified
            if (!Automation1_Variables_SetGlobalIntegers(controller, index, &newValue, 1)) {
                printError();
                return;
            }

            // Use PRId64 to print int64_t types
            printf("$iglobal[%d] is now set to: %" PRId64 "\n", index, newValue);
        }

        /// <summary>
        /// Shows common parameter values for an axis.
        /// </summary>
        /// <param name="axis">The axis to show parameter values for.</param>
        void showAxisParameters(int32_t axis)
        {
            // Controller parameters can be accessed through the Automation1_Parameter_Get* functions. They are divided into three categories:
            // Axis, Task, and System parameters. Parameters are then divided into numeric and string parameters, and each have their own
            // function for getting and setting. 
            //
            // The FaultMask, DefaultAxisSpeed, and DefaultAxisRampRate parameters are numeric axis parameters, so we use the 
            // Automation1_Parameter_GetAxisValue function to get their values.
            //
            // For a string axis parameter, use the Automation1_Parameter_GetAxisStringValue() function to get its value.
            double axisFaultMask;
            double defaultAxisSpeed;
            double defaultAxisRampRate;
            if (!Automation1_Parameter_GetAxisValue(controller, axis, Automation1AxisParameterId_FaultMask, &axisFaultMask) ||
                !Automation1_Parameter_GetAxisValue(controller, axis, Automation1AxisParameterId_DefaultAxisSpeed, &defaultAxisSpeed) ||
                !Automation1_Parameter_GetAxisValue(controller, axis, Automation1AxisParameterId_DefaultAxisRampRate, &defaultAxisRampRate))
            {
                printError();
                return;
            }

            // The FaultMask axis parameter is a series of bits that can be masked to get/set the protection status of
            // a specific axis fault. After casting the parameter value to an "int64_t", we can and the result with 
            // our desired Automation1AxisFault enum value and compare it to itself to determine if a specified AxisFault 
            // bit is enabled.
            bool isMotorTemperatureFaultProtectionEnabled = ((int64_t)axisFaultMask & Automation1AxisFault_MotorTemperatureFault) == Automation1AxisFault_MotorTemperatureFault;
            //char* motorTemperatureFaultProtectionStatus = isMotorTemperatureFaultProtectionEnabled ? "Enabled" : "Disabled";
            const char* motorTemperatureFaultProtectionStatus = isMotorTemperatureFaultProtectionEnabled ? "Enabled" : "Disabled";

            printf("Motor Temperature Fault protection: %s\n", motorTemperatureFaultProtectionStatus);
            printf("Default Axis Speed: %f\n", defaultAxisSpeed);
            printf("Default Axis Ramp Rate: %f\n", defaultAxisRampRate);

            // To set the values of controller parameters, use the Automation1_Parameter_Set* functions to set a numeric 
            // or string value for an axis, task, or system parameter.
            // Example:
            //
            // Automation1_Parameter_SetAxisValue(controller, axis, Automation1AxisParameterId_DefaultAxisSpeed, newDefaultAxisSpeed);
            // Automation1_Parameter_SetAxisValue(controller, axis, Automation1AxisParameterId_DefaultAxisRampRate, newDefaultAxisRampRate);
        }

        /// <summary>
        /// Prints the list of commands available to the user.
        /// </summary>
        void printHelp()
        {
            printf("Available commands:\n");
            printf("    Connect\n");
            printf("    Disconnect\n");
            printf("    Start\n");
            printf("    Stop\n");
            printf("    Enable [Axis Index]\n");
            printf("    Disable [Axis Index]\n");
            printf("    Home [Axis Index]\n");
            printf("    Abort [Axis Index]\n");
            printf("    AxisStatus [Axis Index]\n");
            printf("    MoveLinear [Axis Index] [Distance] [Speed]\n");
            printf("    RunProgram [AeroScript Program Path]\n");
            printf("    ProgramStatus\n");
            printf("    StopProgram\n");
            printf("    GetGlobalInteger [Integer Index]\n");
            printf("    SetGlobalInteger [Integer Index] [New Value]\n");
            printf("    ShowAxisParameters [Axis Index]\n");
            printf("    Quit\n");
        }

        /// <summary>
        /// Gets the most recent error from the controller and prints it for the user.
        /// </summary>
        void printError()
        {
            // When a function from the C API fails, an error code and message are stored. We can use 
            // Automation1_GetLastError() to get the most recent error code from the controller. Note 
            // that a subsequent error will overwrite the currently stored code and message.
            int32_t lastError = Automation1_GetLastError();

            // We can then use Automation1_GetLastErrorMessage(buffer, bufferLength) to populate a char array with
            // the error message.
            char lastErrorMessage[2048];
            Automation1_GetLastErrorMessage(lastErrorMessage, 2048);

            printf("    error (%d): %s\n", lastError, lastErrorMessage);
        }

#pragma endregion

#pragma endregion

void *simple_cyclic_task(void *data) // RT Task Creation and RT Loop
{    
        #pragma region temperatureController
            double cmd_laser_power_watt = 0;
            // double process_gain = 4.35; // deg C/W
            // double process_tc = 2.0; // sec
            double depositionSpeed_multiplier = 4.0/5.0;
            double process_gain = 3.9364*depositionSpeed_multiplier; // deg C/W
            double process_tc = 0.6040; // sec

            double laser_power_currentVal = 0;
            double laser_power_prevVal = 0;

            double laser_ref_previousVal = 0.0;
            double laser_ref_currentVal = 0.0;
            double laser_ref_futureVal = 0.0;

            // Compute alpha values from desired time constants
            double tau_naturalFreq = 0.5356; // sec
            double tau1 = tau_naturalFreq * 1.0; // sec
            //double tau2 = tau_naturalFreq * 1.0;
            double tau2 = sample_period_s*1.0; // sec that is 4 times the sample period

            // Compute exponential terms
            double p1 = std::exp(-sample_period_s / tau1);
            double p2 = std::exp(-sample_period_s / tau2);

            // Manual alpha value assignment
            double alpha_0 = 0.3052;
            double alpha_1 = -1.1976;

            // Compute alpha values
            alpha_1 = -(p1 + p2);
            alpha_0 = p1 * p2;

            double pid_interval_dt = sample_period_s;

            double temperature_c_currentVal = 0;
            double temperature_c_prevVal = 0;
            double temperature_c_reference = 0;

            double pid_gain_kp = 0.2007; // MATLAB Gen  // 0.75*17*1.0/process_gain; // 0.013  prev: 1/4.35 = 0.2298
            double pid_gain_ki = 0.1826; // MATLAB Gen // 0.75*60*1.0/(process_gain*process_tc); // 0.006  prev: 1/2 = 0.5

            // PI controller
            double pid_error = 0;
            double pid_error_integral = 0;

            bool enable_pid = false;

            int ilc_counter = 0;
            int ilc_counter_max = 9;
            bool ilc_reiterate = false;
            int ilc_element = 0;
            double ilc_gain = 0.10;
            double ilc_cost = 0.0;

           // double pid_error_
        #pragma endregion

        #pragma region initializeAerotechSys

            char inputBuffer[2048];
            char command[64];
            int32_t arg0;
            double arg1, arg2;
            int numParsed;
            char programPath[1024];
            int64_t newGlobalInteger;

            connectToController();
            startController();
            stopProgram();
            showProgramStatus();
            stopProgram();
            showProgramStatus();
           
            double result[50];

            int32_t axis_z = 0; int32_t axis_y = 1;  int32_t axis_x = 2;  int32_t axis_f = 3; 
            
        #pragma endregion

        #pragma region initializeOptrisCamera
            
            int prbs_state = 0xACE1;

            bool thermalCameraEnable = true;

                // Also we need to do somthing about error checking, if code fails instead of return -1 or exit(-1) what we need to do is populate values with 0s or error code.
                double time_diff = 0;
                // Harcode optris_camera_config_file
                // static const char argument[] = "Modules/Optris_Cam/camConfig.xml";
                int argc = 2;
                static const char* argv[] = {"mainProgramExe.out","Modules/Optris_Cam/camConfig.xml"};
                // char* argv[argc];
                // // char argv[100];
                // char argv[1] = const_cast<char*>(argument);

                if(argc!=2)
                {
                std::cout << "usage: " << argv[0] << " <xml configuration file>" << std::endl;
                // return -1;
                exit(-1);
                }

                if(::evo_irimager_usb_init(argv[1], 0, 0) != 0) exit(-1);
                int err;
                int p_w;
                int p_h;
                if((err = ::evo_irimager_get_palette_image_size(&p_w, &p_h)) != 0)
                {
                std::cerr << "error on evo_irimager_get_palette_image_size: " << err << std::endl;
                exit(-1);
                }

                int t_w;
                int t_h;

                //!width of thermal and palette image can be different due to stride of 4 alignment
                if((err = ::evo_irimager_get_thermal_image_size(&t_w, &t_h)) != 0)
                {
                std::cerr << "error on evo_irimager_get_palette_image_size: " << err << std::endl;
                exit(-1);
                }
                std::vector<unsigned char> palette_image(p_w * p_h * 3);
                std::vector<unsigned short> thermal_data(t_w * t_h);
                
                // Defining for average of max temp
                std::vector<unsigned short> sorted_data = thermal_data;  

                std::cout << "Thermal Camera Config" << std::endl;
                std::cout << "th = " << t_h <<std::endl;
                std::cout << "tw = " << t_w <<std::endl;

                unsigned long int mean = 0;
                float max_temp = 0;

                /*Setup thermal camera settings*/

                /*
                    * @brief sets radiation properties, i.e. emissivity and transmissivity parameters (not implemented for TCP connection, usb mode only)
                    * @param[in] emissivity emissivity of observed object [0;1]
                    * @param[in] transmissivity transmissivity of observed object [0;1]
                    * @param[in] tAmbient ambient temperature, setting invalid values (below -273,15 degrees) forces the library to take its own measurement values.
                    * @return error code: 0 on success, -1 on error, -2 on fatal error (only TCP connection)

                    __IRDIRECTSDK_API__ int evo_irimager_set_radiation_parameters(float emissivity, float transmissivity, float tAmbient);
                */
               float emissivity = 0.72;
               float transmissivity = 1.0;
               float tAmbient = 27;

                if((err = ::evo_irimager_set_radiation_parameters(emissivity,transmissivity,tAmbient)) != 0)
                {
                std::cerr << "uable to set optris radiation parameres (evo_irimager_set_radiation_parameters)" << err << std::endl;
                exit(-1);
                }
                /*
                    * @brief sets the minimum and maximum remperature range to the camera. Only values which are defined in teh optris cali files are supported. (also configurable in xml-config)
                    * @param[in] t_min Minimal temperature (has to be defined in the optris cali files) 
                    * @param[in] t_min Maximal temperature (has to be defined in the optris cali files)
                    * @return error code: 0 on success, -1 on error, -2 on fatal error (only TCP connection)

                    __IRDIRECTSDK_API__ int evo_irimager_set_temperature_range(int t_min, int t_max);
                    
                    Possible ranges -20 to 100; 200 to 1500; 150 to 900C
                */
                int t_min = 200; 
                int t_max = 1500;
                if((err = ::evo_irimager_set_temperature_range(t_min,t_max)) != 0)
                {
                std::cerr << "uable to set optris max and min temp (evo_irimager_set_temperature_range)" << err << std::endl;
                exit(-1);
                }

                EvoIRFrameMetadata meta;

                /*
                    * @brief sets shutter flag control mode
                    * @param mode 0 means manual control, 1 means automode
                    * @return error code: 0 on success, -1 on error, -2 on fatal error (only TCP connection)
                    
                    __IRDIRECTSDK_API__ int evo_irimager_set_shutter_mode(int mode);
                */
            //    int optris_shutter_mode = 0;
            //     if((err = ::evo_irimager_set_shutter_mode(optris_shutter_mode)) != 0)
            //     {
            //     std::cerr << "uable to set optris shutter mode (evo_irimager_set_shutter_mode)" << err << std::endl;
            //     exit(-1);
            //     }

                /*
                 * @brief forces a shutter flag cycle
                 * @return error code: 0 on success, -1 on error, -2 on fatal error (only TCP connection)
                
                __IRDIRECTSDK_API__ int evo_irimager_trigger_shutter_flag();
                */

                // if((err = ::evo_irimager_trigger_shutter_flag()) != 0)
                // {
                // std::cerr << "uable to flag optris shutter  (evo_irimager_trigger_shutter_flag)" << err << std::endl;
                // exit(-1);
                // }

            

        #pragma endregion

        #pragma region motionPlanQueueAerotech

            Automation1CommandQueue commandQueue = NULL;
            Automation1CommandQueueStatus commandStatus;
            Automation1TargetMode incrementalMode = Automation1TargetMode_Incremental;
            int32_t task1 = 1;
            
            if (!Automation1_CommandQueue_Begin(controller, task1, 1000, false, &commandQueue)) {  std::cout << "Error: Automation1 Failed to run Automation1_CommandQueue_Begin. \n";}
           
            // PAUSE 1

            //     1      | 0001   |  0  |  0  |  0  |  1  | Initialized, queue created
            #pragma region setProgramStatusToQueueCreated

                std::string mystring = "DigitalOutputSet(Z,0,1)";
                if (!Automation1_CommandQueue_Execute(commandQueue, mystring.c_str())) 
                {
                    char errMsg[2048];
                    Automation1_GetLastErrorMessage(errMsg, sizeof(errMsg));
                    std::cerr << "Error executing command: " << errMsg << std::endl;
                }

                mystring = "DigitalOutputSet(Z,1,0)";
                if (!Automation1_CommandQueue_Execute(commandQueue, mystring.c_str())) 
                {
                    char errMsg[2048];
                    Automation1_GetLastErrorMessage(errMsg, sizeof(errMsg));
                    std::cerr << "Error executing command: " << errMsg << std::endl;
                }

                mystring = "DigitalOutputSet(Z,2,0)";
                if (!Automation1_CommandQueue_Execute(commandQueue, mystring.c_str())) 
                {
                    char errMsg[2048];
                    Automation1_GetLastErrorMessage(errMsg, sizeof(errMsg));
                    std::cerr << "Error executing command: " << errMsg << std::endl;
                }

                mystring = "DigitalOutputSet(Z,3,0)";
                if (!Automation1_CommandQueue_Execute(commandQueue, mystring.c_str())) 
                {
                    char errMsg[2048];
                    Automation1_GetLastErrorMessage(errMsg, sizeof(errMsg));
                    std::cerr << "Error executing command: " << errMsg << std::endl;
                }

            #pragma endregion



            if (!Automation1_CommandQueue_Pause(commandQueue)) { std::cout << "Error: Automation1 Failed to run Automation1_CommandQueue_Pause. \n";}
           
            if (!Automation1_CommandQueue_VelocityBlendingOn(commandQueue)) { /* handle error */ }
            if (!Automation1_CommandQueue_VelocityBlendingOff(commandQueue)) { /* handle error */ }
            
            if (!Automation1_CommandQueue_Enable(commandQueue, &axis_x, 1)) { /* handle error */ }
            if (!Automation1_CommandQueue_Enable(commandQueue, &axis_y, 1)) { /* handle error */ }
            if (!Automation1_CommandQueue_Enable(commandQueue, &axis_z, 1)) { /* handle error */ }
            if (!Automation1_CommandQueue_Enable(commandQueue, &axis_f, 1)) { /* handle error */ }

            int32_t axes_xyz[] = {axis_x, axis_y, axis_z}; 

            if (!Automation1_CommandQueue_SetupTaskTargetMode(commandQueue,Automation1TargetMode_Incremental)) { std::cout << "Error: Automation1 Failed to run Automation1_CommandQueue_SetupTaskTargetMode = Inc. \n"; }
            
            if(!Automation1_CommandQueue_GetStatus(commandQueue,&commandStatus)) {std::cout << "Error: Automation1 Failed to run Automation1_CommandQueue_GetStatus. \n";}
            
            std::cout << "commandStatus.IsEmpty = " << commandStatus.IsEmpty << "\n";
            std::cout << "commandStatus.IsPaused  = " << commandStatus.IsPaused << "\n";
            std::cout << "commandStatus.NumberOfExecutedCommands = " << commandStatus.NumberOfExecutedCommands<< "\n";
            std::cout << "commandStatus.NumberOfTimesEmptied = " << commandStatus.NumberOfTimesEmptied << "\n";
            std::cout << "commandStatus.NumberOfUnexecutedCommands = " << commandStatus.NumberOfUnexecutedCommands << "\n";

          
            int32_t axes_xy[] = {axis_x, axis_y};  // Array containing the axes identifiers
            int32_t axes_xf[] = {axis_x, axis_f}; 
            int32_t axes_yf[] = {axis_y, axis_f}; 
            int32_t axes_zf[] = {axis_z, axis_f}; 

            // if( !Automation1_CommandQueue_CornerRoundingOff(commandQueue)) { std::cout << "Error: Corner round enable \n"; }       
            if (!Automation1_CommandQueue_VelocityBlendingOn(commandQueue)) { /* handle error */ }
            if (!Automation1_CommandQueue_SetupTaskTargetMode(commandQueue,Automation1TargetMode_Incremental)) { /* handle error */ }

            // Read the G-Code and push it into the queue.

            std::ifstream gcodeFile("aerotechGCode-Active.txt");


            if (!gcodeFile.is_open()) {
                std::cerr << "Error: Could not open G-code file 'aerotechGCode-Active.txt'\n";
            } else {
                std::string line;
                int lineNumber = 1;

                while (std::getline(gcodeFile, line)) {
                    // Skip empty lines or comments
                    if (line.empty() || line[0] == ';' || line[0] == '#') {
                        ++lineNumber;
                        continue;
                    }

                    std::cout << "Line " << lineNumber << ": " << line << std::endl;

                    if (!Automation1_CommandQueue_Execute(commandQueue, line.c_str())) {
                        char errMsg[2048];
                        Automation1_GetLastErrorMessage(errMsg, sizeof(errMsg));
                        std::cerr << "Error executing line " << lineNumber << ": " << errMsg << std::endl;
                        // You can break here if you want to stop on first error
                    }

                    ++lineNumber;
                }

                gcodeFile.close();
            }

            


            //     0      | 0000   |  0  |  0  |  0  |  0  | Ready to quit / shutdown
            #pragma region setProgramStatusToShutdown

                mystring = "DigitalOutputSet(Z,0,0)";
                if (!Automation1_CommandQueue_Execute(commandQueue, mystring.c_str())) 
                {
                    char errMsg[2048];
                    Automation1_GetLastErrorMessage(errMsg, sizeof(errMsg));
                    std::cerr << "Error executing command: " << errMsg << std::endl;
                }

                mystring = "DigitalOutputSet(Z,1,0)";
                if (!Automation1_CommandQueue_Execute(commandQueue, mystring.c_str())) 
                {
                    char errMsg[2048];
                    Automation1_GetLastErrorMessage(errMsg, sizeof(errMsg));
                    std::cerr << "Error executing command: " << errMsg << std::endl;
                }

                mystring = "DigitalOutputSet(Z,2,0)";
                if (!Automation1_CommandQueue_Execute(commandQueue, mystring.c_str())) 
                {
                    char errMsg[2048];
                    Automation1_GetLastErrorMessage(errMsg, sizeof(errMsg));
                    std::cerr << "Error executing command: " << errMsg << std::endl;
                }

                mystring = "DigitalOutputSet(Z,3,0)";
                if (!Automation1_CommandQueue_Execute(commandQueue, mystring.c_str())) 
                {
                    char errMsg[2048];
                    Automation1_GetLastErrorMessage(errMsg, sizeof(errMsg));
                    std::cerr << "Error executing command: " << errMsg << std::endl;
                }

            #pragma endregion






          
            int32 flag_execute_queue = 1;

            
            Automation1StatusConfig statusConfig_captureAerotechData;
            if(!Automation1_StatusConfig_Create(&statusConfig_captureAerotechData)) {printf("Error Automation1_StatusConfig_Create(&statusConfig_captureAerotechData)");}

            // category using the Automation1_StatusConfig_AddAxisStatusItem(statusConfig, axis, axisStatusItem, argument) function.
            //int32_t axis_z = 0; int32_t axis_y = 1;  int32_t axis_x = 2; 
            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_ProgramPositionFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_ProgramPositionFeedback, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_ProgramPositionFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_ProgramPositionFeedback, 0)");} // Z axis
              
            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramPositionFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramPositionFeedback, 0)");} // Z axis
            
            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_ProgramPositionFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramPositionFeedback, 0)");} // Z axis
            
            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_ProgramVelocityFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_ProgramVelocityFeedback, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_ProgramVelocityFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_ProgramVelocityFeedback, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramVelocityFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramVelocityFeedback, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_ProgramVelocityFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_ProgramVelocityFeedback, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_AccelerationFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_AccelerationFeedback, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_AccelerationFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_AccelerationFeedback, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_AccelerationFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_AccelerationFeedback, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_AccelerationFeedback, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_AccelerationFeedback, 0)");} // Z axis

            // Capture Commanded values next
            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_ProgramPositionCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_ProgramPositionCommand, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_ProgramPositionCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_ProgramPositionCommand, 0)");} // Z axis
              
            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramPositionCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramPositionCommand, 0)");} // Z axis
            
            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_ProgramPositionCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramPositionCommand, 0)");} // Z axis
            
            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_ProgramVelocityCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_ProgramVelocityCommand, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_ProgramVelocityCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_ProgramVelocityCommand, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramVelocityCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_ProgramVelocityCommand, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_ProgramVelocityCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_ProgramVelocityCommand, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_AccelerationCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_AccelerationCommand, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_AccelerationCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_y, Automation1AxisStatusItem_AccelerationCommand, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_AccelerationCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_x, Automation1AxisStatusItem_AccelerationCommand, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_AccelerationCommand, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_f, Automation1AxisStatusItem_AccelerationCommand, 0)");} // Z axis

            if(!Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_DigitalOutput, 0)) 
            {printf("Error Automation1_StatusConfig_AddAxisStatusItem(statusConfig_captureAerotechData, axis_z, Automation1AxisStatusItem_DigitalOutput, 0)");} // Z axis Digital Output



        #pragma endregion

        #pragma region initializeVisualCamera // Initialization code for the camera   
            
            bool VisualCameraEnable = false;
            cout << "Atleast we reached this point: " << endl << endl;         
                int32 currentIndex = 0; // Initialize a counter for the current index

                SystemPtr system = System::GetInstance();
                CameraList camList = system->GetCameras();

                unsigned int numCameras = camList.GetSize();
 
                cout << "Number of cameras detected: " << numCameras << endl << endl;
 

                if (camList.GetSize() == 0) {
                        // No cameras detected
                        system->ReleaseInstance();
                        return NULL;
                }

                // Use the first camera
                CameraPtr pCam = camList.GetByIndex(0);
                pCam->Init();

                INodeMap& nodeMap = pCam->GetNodeMap();
                // Configure the camera (e.g., set trigger mode)
                //ConfigureTrigger(nodeMap);
                // Configure Trigger
                CEnumerationPtr ptrTriggerMode = nodeMap.GetNode("TriggerMode");
                CEnumEntryPtr ptrTriggerModeOff = ptrTriggerMode->GetEntryByName("Off");
                ptrTriggerMode->SetIntValue(ptrTriggerModeOff->GetValue());

                CEnumerationPtr ptrTriggerSelector = nodeMap.GetNode("TriggerSelector");
                CEnumEntryPtr ptrTriggerSelectorFrameStart = ptrTriggerSelector->GetEntryByName("FrameStart");
                ptrTriggerSelector->SetIntValue(ptrTriggerSelectorFrameStart->GetValue());

                CEnumerationPtr ptrTriggerSource = nodeMap.GetNode("TriggerSource");
                CEnumEntryPtr ptrTriggerSourceSoftware = ptrTriggerSource->GetEntryByName("Software");
                ptrTriggerSource->SetIntValue(ptrTriggerSourceSoftware->GetValue());

                CEnumEntryPtr ptrTriggerModeOn = ptrTriggerMode->GetEntryByName("On");
                ptrTriggerMode->SetIntValue(ptrTriggerModeOn->GetValue());

                // Set buffer framerate and rest of the things

                // Set frame rate to 10 Hz
                CBooleanPtr ptrAcquisitionFrameRateEnable = nodeMap.GetNode("AcquisitionFrameRateEnable");
                if (IsAvailable(ptrAcquisitionFrameRateEnable) && IsWritable(ptrAcquisitionFrameRateEnable)) {
                    ptrAcquisitionFrameRateEnable->SetValue(true);
                }

                CFloatPtr ptrFrameRate = nodeMap.GetNode("AcquisitionFrameRate");
                if (IsAvailable(ptrFrameRate) && IsWritable(ptrFrameRate)) {
                    ptrFrameRate->SetValue(60.0);  // Set to 10 Hz
                    cout << "Frame rate set to: " << ptrFrameRate->GetValue() << " Hz" << endl;
                } else {
                    cout << "Failed to set frame rate." << endl;
                }

                // Set the buffer size to handle more images
                INodeMap& streamNodeMap = pCam->GetTLStreamNodeMap();
                CIntegerPtr ptrBufferCount = streamNodeMap.GetNode("StreamBufferCountManual");
                if (IsAvailable(ptrBufferCount) && IsWritable(ptrBufferCount)) {
                    ptrBufferCount->SetValue(60);  // Adjust as needed
                    cout << "Buffer size set to: " << ptrBufferCount->GetValue() << " images" << endl;
                } else {
                    cout << "Failed to set buffer size." << endl;
                }

                // Retrieve Buffer Handling Mode Information using your existing streamNodeMap
                CEnumerationPtr ptrHandlingMode = streamNodeMap.GetNode("StreamBufferHandlingMode");
                if (!IsReadable(ptrHandlingMode) || !IsWritable(ptrHandlingMode)) {
                    cout << "Unable to retrieve or set Buffer Handling mode. Aborting..." << endl;
                    //return -1;
                }

                // Define buffer handling modes you want to set
                const std::vector<gcstring> bufferHandlingModes = {
                    "NewestFirst"};

                // Iterate through each buffer handling mode and set it
                for (const auto& modeName : bufferHandlingModes) {
                    // Retrieve the corresponding entry for the buffer handling mode
                    CEnumEntryPtr ptrHandlingModeEntry = ptrHandlingMode->GetEntryByName(modeName.c_str());
                    if (!IsReadable(ptrHandlingModeEntry)) {
                        cout << "Unable to retrieve Buffer Handling Mode entry for '" << modeName << "'. Skipping..." << endl;
                        continue;
                    }

                    // Set the buffer handling mode to the retrieved entry
                    ptrHandlingMode->SetIntValue(ptrHandlingModeEntry->GetValue());

                    // Print the currently set buffer handling mode
                    cout << "Buffer Handling Mode set to: " << ptrHandlingMode->GetCurrentEntry()->GetDisplayName() << endl;

                    // Optional: Perform acquisition or any other operations here before moving to the next mode
                    // pCam->BeginAcquisition(); // Start acquisition (if needed)
                    // pCam->EndAcquisition();   // Stop acquisition (if needed)
                }

                // Set the buffer handling mode to "NewestOnly"
                CEnumerationPtr ptrBufferHandlingMode = streamNodeMap.GetNode("StreamBufferHandlingMode");
                CEnumEntryPtr ptrHandlingNewestOnly = ptrBufferHandlingMode->GetEntryByName("NewestOnly");

                // Check the current buffer handling mode and print it
                if (IsReadable(ptrBufferHandlingMode)) {
                    CEnumEntryPtr currentMode = ptrBufferHandlingMode->GetCurrentEntry();
                    cout << "Current buffer handling mode: " << currentMode->GetSymbolic() << endl;
                } else {
                    cout << "Failed to read the current buffer handling mode." << endl;
                }

                        




                ImageProcessor processor;
                processor.SetColorProcessing(SPINNAKER_COLOR_PROCESSING_ALGORITHM_HQ_LINEAR);
                // int64_t acquisitionModeContinuous = ptrAcquisitionModeContinuous->GetValue();

                //ptrAcquisitionMode->SetIntValue(acquisitionModeContinuous);

                // Begin acquiring images
                 pCam->BeginAcquisition();

                cout << "Acquiring images..." << endl;

                CCommandPtr ptrSoftwareTriggerCommand = nodeMap.GetNode("TriggerSoftware");
                                if (IsWritable(ptrSoftwareTriggerCommand)) {
                                ptrSoftwareTriggerCommand->Execute();
                                }
            #pragma endregion

        #pragma region realtimeClockCounters
        struct period_info pinfo; // Declare a period_info structure to keep track of the period
        periodic_task_init(&pinfo); // Initialize the periodic task with the current time
        int64_t loop_counter = 0; // Counter for the loop iterations
        #pragma endregion
       
        #pragma region NI_DAQmxInit1
             float64 bias = 0;
            // // DAQmx Task Creating for Encoder Readout
             int32		error=0;
            // TaskHandle	taskHandle=0;
             int32		read;
             float64		motorAngle;
             float64		linearPos = 0.0;
            // float64         linearPosScale = (-1.0)*(1.0/360.0)*(1.0/5.0)*20.0*0.001; // Meter

            // // Linear Axis float64         linearPosScale = (-1)*(1/360)*(1/3)*20;
            // // Ram Press  float64         linearPosScale = (-1)*(1/360)*(1/5)*20;
            char		errBuff[2048]={'\0'};

            
            // TaskHandle	taskHandleA=0;

            // DAQmx Task Creation for Analog Out so you cannot do that according to the ni forum: https://forums.ni.com/t5/Multifunction-DAQ/Is-it-possible-to-create-multiple-AI-tasks-with-NI-DAQmx-Base-3/td-p/1038453
            // But nowwhere it does say counter/ and analog output can be two tasks. Do
            // int		error=0;
            TaskHandle	taskHandleB=0;
            //char		errBuff[2048]={'\0'};
            float64         AO1_cmd[1] = {0.0}; // Array with just one element at index 0
            // float64         speedRefScale = (1000.0/10.0)*(1.0/5.0)*(1.0/60.0)*(20.0)*0.001;
            // float64		speedRef = 0.0;

            // DAQmx Task Creating for Analog Input from the NI DAQmx Board
            TaskHandle	taskHandleC=0;
            int32       readF;
            float64 Ain[8] = {0,0,0,0,0,0,0,0};
            int32 sampsPerChanRead = 0;

            // TaskHandle	taskHandleD=0;
            // uInt8       servo_enable_data[8]={0,1,0,0,0,0,0,0};
            // uInt8       servo_disable_data[8]={0,0,0,0,0,0,0,0};
        #pragma endregion
        
        #pragma region NI_DAQmxInit2
        // DAQmxErrChk (DAQmxCreateTask("ServoEnableTask",&taskHandleD));
	    // DAQmxErrChk (DAQmxCreateDOChan(taskHandleD,"Dev1/port0/line0:7","",DAQmx_Val_ChanForAllLines));
        // DAQmxErrChk (DAQmxStartTask(taskHandleD));
        // DAQmxErrChk (DAQmxWriteDigitalLines(taskHandleD,1,1,10.0,DAQmx_Val_GroupByChannel,servo_enable_data,NULL,NULL));


        // DAQmxErrChk(DAQmxCreateTask("EncoderTask",&taskHandle));

        // DAQmxErrChk(DAQmxCreateCIAngEncoderChan(taskHandle,"cDAQ1Mod1/ctr0","Counter",DAQmx_Val_X4,1,0,DAQmx_Val_AHighBHigh,DAQmx_Val_Degrees,32768,0,""));
        // DAQmxErrChk(DAQmxSetCIEncoderAInputTerm(taskHandle, "cDAQ1Mod1/ctr0", "/cDAQ1Mod1/PFI0"));
        // DAQmxErrChk(DAQmxSetCIEncoderBInputTerm(taskHandle, "cDAQ1Mod1/ctr0", "/cDAQ1Mod1/PFI1"));
        // DAQmxErrChk(DAQmxSetCIEncoderZInputTerm(taskHandle, "cDAQ1Mod1/ctr0", "/cDAQ1Mod1/PFI2"));
 
        // DAQmxErrChk(DAQmxSetCIEncoderAInputDigFltrEnable(taskHandle, "cDAQ1Mod1/ctr0", TRUE));
        // DAQmxErrChk(DAQmxSetCIEncoderAInputDigFltrMinPulseWidth(taskHandle, "cDAQ1Mod1/ctr0", 125e-9));
        // DAQmxErrChk(DAQmxSetCIEncoderBInputDigFltrEnable(taskHandle, "cDAQ1Mod1/ctr0", TRUE));
        // DAQmxErrChk(DAQmxSetCIEncoderBInputDigFltrMinPulseWidth(taskHandle, "cDAQ1Mod1/ctr0", 125e-9));
        // DAQmxErrChk(DAQmxSetCIEncoderZInputDigFltrEnable(taskHandle, "cDAQ1Mod1/ctr0", TRUE));
        // DAQmxErrChk(DAQmxSetCIEncoderZInputDigFltrMinPulseWidth(taskHandle, "cDAQ1Mod1/ctr0", 2.560000e-3));

      
        // DAQmxErrChk(DAQmxStartTask(taskHandle));

        // This code is to set laser power to desired value - taskHandleB
        DAQmxErrChk (DAQmxCreateTask("AnalogOutTask",&taskHandleB));
	    DAQmxErrChk (DAQmxCreateAOVoltageChan(taskHandleB,"Dev1/ao0","",0.0,10.0,DAQmx_Val_Volts,""));
        DAQmxErrChk (DAQmxStartTask(taskHandleB));
        
        // This code is to read laser power to desired value - taskHandleC
        DAQmxErrChk (DAQmxCreateTask("AnalogInTask",&taskHandleC));
        DAQmxErrChk (DAQmxCreateAIVoltageChan(taskHandleC,"Dev1/ai0:7","",DAQmx_Val_RSE,-10.0,10.0,DAQmx_Val_Volts,NULL));
        DAQmxErrChk (DAQmxStartTask(taskHandleC));
        #pragma endregion
    
        #pragma region lineScannerInit // Initialization code for the line scanner
                // lineScanData_profileX.resize(num_samples_mem_allocation, std::vector<float64>(2048, 0.0));
                // lineScanData_profileZ.resize(num_samples_mem_allocation, std::vector<float64>(2048, 0.0));
                // lineScanData_timestamp.resize(num_samples_mem_allocation, std::vector<float64>(2, 0.0));
                // float lol_troll = 0;
                // gint32 ret = 0;

                // char *interfaces[MAX_INTERFACE_COUNT];
                // guint32 resolutions[MAX_RESOLUTION];
                // guint32 interface_count = 0;

                // guint32 idle_time = 20;
                // guint32 exposure_time = 10;

                // if ((ret = CInterfaceLLT::GetDeviceInterfaces(&interfaces[0], MAX_INTERFACE_COUNT)) ==
                //     ERROR_GETDEVINTERFACE_REQUEST_COUNT) {
                //     std::cout << "There are more than " << MAX_INTERFACE_COUNT << " scanCONTROL connected" << std::endl;
                //     interface_count = MAX_INTERFACE_COUNT;
                // } else if (ret < 1) {
                //     std::cout << "A error occured during searching for connected scanCONTROL" << std::endl;
                //     interface_count = 0;
                // } else {
                //     interface_count = ret;
                // }

                // if (interface_count == 0) {
                //     std::cout << "There is no scanCONTROL connected - Exiting" << std::endl;
                //     exit(0);
                // } else if (interface_count == 1) {
                //     std::cout << "There is 1 scanCONTROL connected " << std::endl;
                // } else {
                //     std::cout << "There are " << interface_count << " scanCONTROL connected" << std::endl;
                // }

                // for (guint32 i = 0; i < interface_count; i++) {
                //     std::cout << interfaces[i] << "" << std::endl;
                // }

                // // new LLT instance
                // hLLT = new CInterfaceLLT();
                // event = CInterfaceLLT::CreateEvent();

                // if ((ret = hLLT->SetDeviceInterface(interfaces[0])) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while setting dev id " << ret << "!" << std::endl;
                //     //goto cleanup;
                // }

                // // connect to sensor
                // if ((ret = hLLT->Connect()) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while connecting to camera - Error " << ret << "!" << std::endl;
                //     //goto cleanup;
                // }

                // if ((ret = hLLT->GetLLTType(&llt_type)) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while GetLLTType!" << std::endl;
                //     //goto cleanup;
                // }

                // if (ret == GENERAL_FUNCTION_DEVICE_NAME_NOT_SUPPORTED) {
                //     std::cout << "Can't decode scanCONTROL type. Please contact Micro Epsilon for a newer version of the library."
                //             << std::endl;
                //     //goto cleanup;
                // }

                // if (llt_type >= scanCONTROL27xx_25 && llt_type <= scanCONTROL27xx_xxx) {
                //     std::cout << "The scanCONTROL is a scanCONTROL27xx" << std::endl;
                // } else if (llt_type >= scanCONTROL26xx_25 && llt_type <= scanCONTROL26xx_xxx) {
                //     std::cout << "The scanCONTROL is a scanCONTROL26xx" << std::endl;
                // } else if (llt_type >= scanCONTROL29xx_25 && llt_type <= scanCONTROL29xx_xxx) {
                //     std::cout << "The scanCONTROL is a scanCONTROL29xx" << std::endl;
                // } else if (llt_type >= scanCONTROL30xx_25 && llt_type <= scanCONTROL30xx_xxx) {
                //     std::cout << "The scanCONTROL is a scanCONTROL30xx" << std::endl;
                // } else if (llt_type >= scanCONTROL25xx_25 && llt_type <= scanCONTROL25xx_xxx) {
                //     std::cout << "The scanCONTROL is a scanCONTROL25xx" << std::endl;
                // } else {
                //     std::cout << "The scanCONTROL is a undefined type\nPlease contact Micro-Epsilon for a newer SDK" << std::endl;
                //     //goto cleanup;
                // }

                // std::cout << "Get all possible resolutions" << std::endl;
                // if ((ret = hLLT->GetResolutions(&resolutions[0], MAX_RESOLUTION)) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error GetResolutions!" << std::endl;
                //     //goto cleanup;
                // }

                // // set Resolution to max
                // resolution = resolutions[0];

                // if (hLLT->SetResolution(resolution) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while setting transmission mode!" << std::endl;
                //     //goto cleanup;
                // }

                // if (hLLT->SetProfileConfig(PROFILE) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while setting SetProfileConfig!" << std::endl;
                //     //goto cleanup;
                // }

                // if (hLLT->SetFeature(FEATURE_FUNCTION_IDLE_TIME, idle_time) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while setting FEATURE_FUNCTION_IDLE_TIME!" << std::endl;
                //     //goto cleanup;
                // }

                // if (hLLT->SetFeature(FEATURE_FUNCTION_EXPOSURE_TIME, exposure_time) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while setting FEATURE_FUNCTION_EXPOSURE_TIME!" << std::endl;
                //     //goto cleanup;
                // }

                // if (hLLT->SetFeature(FEATURE_FUNCTION_TRIGGER, TRIG_INTERNAL) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while setting FEATURE_FUNCTION_TRIGGER!" << std::endl;
                //     //goto cleanup;
                // }

                // std::cout << "Register callbacks" << std::endl;

                // // register Callbacks for program handling
                // if (hLLT->RegisterBufferCallback((gpointer)&NewProfile, NULL) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while registering buffer callback!" << std::endl;
                //     //goto cleanup;
                // }

                // if (hLLT->RegisterControlLostCallback((gpointer)&ControlLostCallback, NULL) < GENERAL_FUNCTION_OK) {
                //     std::cout << "Error while registering control lost callback!" << std::endl;
                //     ////goto cleanup;
                // }



            //     if (GetProfilesCallback() < GENERAL_FUNCTION_OK) {
            //         std::cout << "Error in GetProfiles_Callback!" << std::endl;
            //         ////goto cleanup;
            //     }

            //     // disconnect to sensor
            //     std::cout << "Disconnect" << std::endl;
            //     if ((ret = hLLT->Disconnect()) < GENERAL_FUNCTION_OK) {
            //         std::cout << "Error while disconnecting to camera - Error " << ret << "!" << std::endl;
            //     }

            // cleanup:
            //     delete hLLT;
            //     CInterfaceLLT::FreeEvent(event);

        #pragma endregion

        #pragma region real_time_loop

        // Print program execution data
        std::cout << "---------------------------------\n";
        std::cout << "Execution Parameters:\n";
        std::cout << "---------------------------------\n";
        std::cout << "Total Time: " << total_time << " seconds\n";
        std::cout << "Sample Period: " << sample_period << " milliseconds (" << sample_period_s << " seconds)\n";
        std::cout << "Total Loop Iterations: " << total_loop_iterations << "\n";
        std::cout << "Data Folder Location: " << folder << "\n";
        std::cout << "---------------------------------\n";

        enable_pid = false;


        // double desired_laserpower_watt = 30.0;
        // double desired_temperature_celcius = 0.0;

        temperature_c_reference = desired_temperature_celcius;

        // generateLaserReferenceSignal(temperature_c_reference);

    
                 

        
        while ( loop_counter < total_loop_iterations) 
        { 

                struct task_timestamps current_timestamp;
                clock_gettime(CLOCK_MONOTONIC, &current_timestamp.start_time);
    
                // ******************** RT TASK

                #pragma region acquireAerotechData
                
                if (!Automation1_Status_GetResults(controller, statusConfig_captureAerotechData, result, 25))
                {
                    printf("Failed to get axis %d status\n will crash program now", 0);
                    printError();
                    Automation1_StatusConfig_Destroy(statusConfig_captureAerotechData);
                    //return;
                }
                aerotech_z_axis_posFbk[loop_counter] = result[0];
                aerotech_y_axis_posFbk[loop_counter] = result[1];
                aerotech_x_axis_posFbk[loop_counter] = result[2];
                aerotech_f_axis_posFbk[loop_counter] = result[3];
                aerotech_z_axis_velFbk[loop_counter] = result[4];
                aerotech_y_axis_velFbk[loop_counter] = result[5];
                aerotech_x_axis_velFbk[loop_counter] = result[6];
                aerotech_f_axis_velFbk[loop_counter] = result[7];
                aerotech_z_axis_accFbk[loop_counter] = result[8];
                aerotech_y_axis_accFbk[loop_counter] = result[9];
                aerotech_x_axis_accFbk[loop_counter] = result[10];
                aerotech_f_axis_accFbk[loop_counter] = result[11];

                aerotech_z_axis_posCmd[loop_counter] = result[12];
                aerotech_y_axis_posCmd[loop_counter] = result[13];
                aerotech_x_axis_posCmd[loop_counter] = result[14];
                aerotech_f_axis_posCmd[loop_counter] = result[15];
                aerotech_z_axis_velCmd[loop_counter] = result[16];
                aerotech_y_axis_velCmd[loop_counter] = result[17];
                aerotech_x_axis_velCmd[loop_counter] = result[18];
                aerotech_f_axis_velCmd[loop_counter] = result[19];
                aerotech_z_axis_accCmd[loop_counter] = result[20];
                aerotech_y_axis_accCmd[loop_counter] = result[21];
                aerotech_x_axis_accCmd[loop_counter] = result[22];
                aerotech_f_axis_accCmd[loop_counter] = result[23];
                aerotech_z_axis_DO[loop_counter] = result[24];

                // Update Path Length Vector
                if (loop_counter > 0)
                    {
                        pathLength_mm[loop_counter] = pathLength_mm[loop_counter - 1]
                            + std::sqrt(
                                (aerotech_x_axis_posCmd[loop_counter] - aerotech_x_axis_posCmd[loop_counter - 1]) *
                                (aerotech_x_axis_posCmd[loop_counter] - aerotech_x_axis_posCmd[loop_counter - 1])
                            + (aerotech_y_axis_posCmd[loop_counter] - aerotech_y_axis_posCmd[loop_counter - 1]) *
                                (aerotech_y_axis_posCmd[loop_counter] - aerotech_y_axis_posCmd[loop_counter - 1])
                            + (aerotech_z_axis_posCmd[loop_counter] - aerotech_z_axis_posCmd[loop_counter - 1]) *
                                (aerotech_z_axis_posCmd[loop_counter] - aerotech_z_axis_posCmd[loop_counter - 1])
                            );
                    }
                else
                    {
                        pathLength_mm[loop_counter] = 0.0;
                    }


                // Estimate the direction of motion based on aerotech feedback or command positions on the fly
                if(loop_counter>5) 
                {
                    
                    // Estimate the direction of motion based on aerotech feedback or command positions on the fly
                        // Calculate delta values for x and y positions for direction estimation
                        delta_x_for_direction_estimation = aerotech_x_axis_posFbk[loop_counter] - aerotech_x_axis_posFbk[loop_counter - 1];
                        delta_y_for_direction_estimation = aerotech_y_axis_posFbk[loop_counter] - aerotech_y_axis_posFbk[loop_counter - 1];

                        // Calculate the magnitude of motion for direction estimation
                        motion_magnitude_for_direction_estimation = sqrt(
                            delta_x_for_direction_estimation * delta_x_for_direction_estimation + 
                            delta_y_for_direction_estimation * delta_y_for_direction_estimation
                        );

                        // Determine the direction angle based on motion threshold
                        if (motion_magnitude_for_direction_estimation < MOTION_DIRECTION_ESTIMATION_THRESHOLD) {
                            estimated_direction_theta_from_encoders = 0.0; // No significant motion
                        } else {
                            estimated_direction_theta_from_encoders = ( atan2(delta_y_for_direction_estimation, delta_x_for_direction_estimation) * radians_to_degrees ) - MOTION_DIRECTION_ESTIMATION_camera_offset ; // Calculate angle in degree
                        }

                        optris_observationAngle[loop_counter] = estimated_direction_theta_from_encoders;

                }


                #pragma endregion

                #pragma region acquireOptrisData
                thermalCameraEnable = true;
                if(thermalCameraEnable) 
                {
                    /* Documentation on thermal palette image
                        * @brief Accessor to an RGB palette image and a thermal image by reference
                        * @param[in] w_t width of thermal image
                        * @param[in] h_t height of thermal image
                        * @param[out] data_t data pointer to unsigned short array allocate by the user (size of w * h)
                        * @param[in] w_p width of palette image (can differ from thermal image width due to striding)
                        * @param[in] h_p height of palette image (can differ from thermal image height due to striding)
                        * @param[out] data_p data pointer to unsigned char array allocate by the user (size of 3 * w * h)
                        * @return error code: 0 on success, -1 on error, -2 on fatal error (only TCP connection)

                        __IRDIRECTSDK_API__ int evo_irimager_get_thermal_palette_image(int w_t, int h_t, unsigned short* data_t, int w_p, int h_p, unsigned char* data_p );
                    
                   
                        * @brief Accessor to thermal image by reference
                        * Conversion to temperature values are to be performed as follows:
                        * t = ((double)data[x] - 1000.0) / 10.0;
                        * @param[in] w image width
                        * @param[in] h image height
                        * @param[out] data pointer to unsigned short array allocate by the user (size of w * h)
                        * @return error code: 0 on success, -1 on error, -2 on fatal error (only TCP connection)

                        __IRDIRECTSDK_API__ int evo_irimager_get_thermal_image(int* w, int* h, unsigned short* data);

                    
                    */
                   
                    // OLD: if((err = ::evo_irimager_get_thermal_palette_image(t_w, t_h, &thermal_data[0], p_w, p_h, &palette_image[0]))==0)
                    if((err = ::evo_irimager_get_thermal_image_metadata(&t_w, &t_h, &thermal_data[0], &meta))==0)
                   
                    {
                        // unsigned long int mean = 0; // Moved up to avoid reinitialization again and again
                        max_temp = 0;
                        // mean = 0;
                        // //--Code for calculation mean temperature of image -----------------
                        for (int y = 0; y < t_h; y++)
                        {
                            for (int x = 0; x < t_w; x++)
                                {
                                    // mean += thermal_data[y*t_w + x];
                                    if(thermal_data[y*t_w + x] > max_temp)
                                        max_temp = thermal_data[y*t_w + x];

                                    optris_TempSlices[loop_counter][x][y] = thermal_data[y * t_w + x] / 10.0 - 100;
                                }
                        }
                        optris_observedMaxTemp[loop_counter] = max_temp / 10.0 - 100;

                        std::partial_sort(thermal_data.begin(), thermal_data.begin() + 400, thermal_data.end(), std::greater<unsigned short>());
                        max_temp = std::accumulate(thermal_data.begin(), thermal_data.begin() + 400, 0.0f) / 400;

                        optris_workzoneRawTemp[loop_counter] = max_temp / 10.0 - 100;

                        if(flag_directionalCorrection)
                        {
                            optris_workzoneCorrectedTemp[loop_counter] = optris_workzoneRawTemp[loop_counter];
                            optris_workzoneCorrectedTemp[loop_counter] = optris_workzoneCorrectedTemp[loop_counter] + ( MOTION_DIRECTION_ESTIMATION_DeltaTempMaxSwing * ( 1 - std::abs(std::cos(estimated_direction_theta_from_encoders * degrees_to_radians / 2.0)) ) );
                            
                            temperature_c_currentVal = optris_workzoneCorrectedTemp[loop_counter];
                        
                            if(loop_counter>5)
                            temperature_c_prevVal = optris_workzoneCorrectedTemp[loop_counter-1];
                        }
                        else // Here we calculate the corrected temperature but pass the raw temperature to the temp controller
                        {   
                            optris_workzoneCorrectedTemp[loop_counter] = optris_workzoneRawTemp[loop_counter];
                            optris_workzoneCorrectedTemp[loop_counter] = optris_workzoneCorrectedTemp[loop_counter] + ( MOTION_DIRECTION_ESTIMATION_DeltaTempMaxSwing * ( 1 - std::abs(std::cos(estimated_direction_theta_from_encoders * degrees_to_radians / 2.0)) ) );

                            temperature_c_currentVal = optris_workzoneRawTemp[loop_counter];
                        
                            if(loop_counter>5)
                            temperature_c_prevVal = optris_workzoneRawTemp[loop_counter-1];
                        }
                        
                        

                        // This value temperature_c_currentVal, and temperature_c_prevVal will be passed to pid controller to reach reference temperature. 
                        // We will just change reference temp and corrected temp


                        // temperature_c_currentVal = optris_workzoneCorrectedTemp[loop_counter];
                        
                        // if(loop_counter>5)
                        // temperature_c_prevVal = optris_workzoneCorrectedTemp[loop_counter-1];

                    }
                    else
                    {
                    //std::cerr << "failed evo_irimager_get_thermal_palette_image: " << err << std::endl;
                    std::cout << "unable to gather datafrom optris, data populated with 0s" << std::endl;
                    }

                    //  if((err = ::evo_irimager_trigger_shutter_flag()) != 0)
                    //     {
                    //     std::cerr << "uable to flag optris shutter  (evo_irimager_trigger_shutter_flag)" << err << std::endl;
                    //     exit(-1);
                    //     }

                }
                #pragma endregion

                #pragma region acquireFLIR_image

                VisualCameraEnable = true;
                if (VisualCameraEnable)//(loop_counter%50==0) 
                {
                        // Image acquisition code
                       // Trigger the camera
                                // CCommandPtr ptrSoftwareTriggerCommand = nodeMap.GetNode("TriggerSoftware");
                                // if (IsWritable(ptrSoftwareTriggerCommand)) {
                                // ptrSoftwareTriggerCommand->Execute();
                                // }

                                // Retrieve the next received image
                                
                                
                                // OLD CODE DELETE ONCE NEW WORKS
                                // ImagePtr pResultImage = pCam->GetNextImage(sample_period);
                                // if (pResultImage->IsIncomplete()) {
                   
                                //         cout << "Error: Unable to capture complete image." << endl;
                                // } else {
                     
                                //         const size_t width = pResultImage->GetWidth();

                                //         const size_t height = pResultImage->GetHeight();

                                //         // Assuming 'currentIndex' is less than 'maxImages'
                                //         if (currentIndex < maxImages - 5) {
                                //                 ImagePtr convertedImage = processor.Convert(pResultImage, PixelFormat_BGR8);
                                                
                                //                 imageStorage[currentIndex] = convertedImage; // Assign the image to the vector
                                //                 currentIndex++; // Move to the next index
                                //         }
                                // }
                                // pResultImage->Release(); // Don't forget to release the image

                                // CCommandPtr ptrSoftwareTriggerCommand = nodeMap.GetNode("TriggerSoftware");
                                // if (IsWritable(ptrSoftwareTriggerCommand)) {
                                // ptrSoftwareTriggerCommand->Execute();
                                // ptrSoftwareTriggerCommand->Execute();
                                // ptrSoftwareTriggerCommand->Execute();
                                // ptrSoftwareTriggerCommand->Execute();
                                // }

                                try {
                                            // Retrieve the next received image
                                            ImagePtr pResultImage = pCam->GetNextImage(sample_period);

                                            // Check if the image status is SPINNAKER_IMAGE_STATUS_NO_ERROR
                                            if (!pResultImage->IsIncomplete() && pResultImage->GetImageStatus() == SPINNAKER_IMAGE_STATUS_NO_ERROR) {
                                                // Process the image if it has no error
                                                const size_t width = pResultImage->GetWidth();
                                                const size_t height = pResultImage->GetHeight();

                                                if (currentIndex < maxImages - 5) {
                                                    ImagePtr convertedImage = processor.Convert(pResultImage, PixelFormat_BGR8);
                                                    imageStorage[currentIndex] = convertedImage; 
                                                    // currentIndex++; // Move to the next index but we want to do this even if the try method failed
                                                }
                                            } else {
                                                cout << "Warning: Image status is not SPINNAKER_IMAGE_STATUS_NO_ERROR. or IsIncomplete" << endl;
                                            }

                                            pResultImage->Release();
                                    } catch (Spinnaker::Exception &e) {
                                        cout << "Warning: Caught Spinnaker exception: " << e.what() << endl;
                                    } catch (std::exception &e) {
                                        cout << "Warning: Caught standard exception: " << e.what() << endl;
                                    } catch (...) {
                                        cout << "Warning: Caught an unknown exception." << endl;
                                    }

                            // Additional triggers as needed
                            CCommandPtr ptrSoftwareTriggerCommand = nodeMap.GetNode("TriggerSoftware");
                            if (IsWritable(ptrSoftwareTriggerCommand)) {
                                ptrSoftwareTriggerCommand->Execute();
                                ptrSoftwareTriggerCommand->Execute();
                                ptrSoftwareTriggerCommand->Execute();
                                ptrSoftwareTriggerCommand->Execute();
                            }
                            currentIndex++; // Move to the next index but we want to do this even if the try method failed
                               

                                

                // Image acquisition code END
                }
                #pragma endregion

                #pragma region LaserControl


                if(loop_counter>5)
                {
  

                    time_diff = (current_timestamp.start_time.tv_sec - timestamps[0].start_time.tv_sec) + 
                                (current_timestamp.start_time.tv_nsec - timestamps[0].start_time.tv_nsec) / 1e9;

                    time_vector_lowPrecision[loop_counter] = time_diff; // To quickly interpret time in the csv dataset.

                   

                    if (time_diff >= 10.0 && time_diff <= 20.0) 
                        {
                            if (pathLength_mm[loop_counter] >= 76)
                            {
                                flag_directionalCorrection = false;
                            }

                            // Update Power Based on ILC Lookup Table
                            if(ILC_PowerUpdateEnable)

                            {       
                                    min_diff = 2.0;
                                    for (std::size_t i = 1; i < kLookupSamples; ++i)
                                    {
                                        diff = std::abs(pathLength_mm[loop_counter] - pathLength[i]);

                                        if (diff < min_diff)
                                        {
                                            min_diff = diff;
                                            closest_idx = i;

                                            if (diff == 0.0)
                                                break;
                                        }
                                    }

                                    desired_laserpower_watt = laserPower[closest_idx]; // From LookupTable

                            }

                            // Full Open Loop Operation 
                            if(openLoopConstantLaserPowerEnable)
                            { // Set laser power to desired value and start the motion program

                                if(openLoopConstantLaserPowerEnable)  // Setup OpenLoop Power
                                {
                                    desired_temperature_C = 0.0;
                                    temperature_c_reference = 0;
                                    laser_power_currentVal = desired_laserpower_watt;
                                    AO1_cmd[0] = convertCmdWattToSetPointVolt(laser_power_currentVal); 
                                    laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                                    laserData_cmdW[loop_counter] = laser_power_currentVal;
                                    enable_pid = false;
                                    laserController_referenceRawTemp[loop_counter] = temperature_c_reference;
                                    enable_pid = false;
                                }

                                 if(flag_execute_queue == 1) // Resume the Aerotech Motion
                                {   
                                    // This will release pause 2 and will move home stage to start position.
                                    if (!Automation1_CommandQueue_Resume(commandQueue)) { std::cout << "Error: Automation1 Failed to run Automation1_CommandQueue_Resume Resume Pause 2. \n"; }
                                    printf("10 sec - start printing glass \n");
                                    flag_execute_queue = 0;
                                }

                                // Make sure the closed loop controller is disabled.
                                openLoopConstantLaserPowerEnable = true;
                                closedLoopControllerEnable = false;
                            }

                            // Full Closed loop Operation
                            if(closedLoopControllerEnable)
                            {
                            // Enable the closed loop controller with laser reference trajectory generation and then enabling print when temperature reaches 800C or above
                                { // Block to generate smooth reference trajectory
                                    desired_temperature_C = desired_temperature_celcius;
                                    if(laserPower_index == 1)
                                    {
                                    
                                    generateLaserReferenceSignal(desired_temperature_C,temperature_c_currentVal);
                                    }
                            

                                    if (laserPower_index > 0 && laserPower_index < laserRefTempStartSmooth.size() - 1) {
                                        
                                        temperature_c_reference = laserRefTempStartSmooth[laserPower_index];
                                        laser_ref_previousVal = laserRefTempStartSmooth[laserPower_index-1];
                                        laser_ref_currentVal = laserRefTempStartSmooth[laserPower_index];
                                        laser_ref_futureVal = laserRefTempStartSmooth[laserPower_index+1];


                                    } else if (laserPower_index > 0) 
                                    {
                                        temperature_c_reference = laserRefTempStartSmooth[laserPower_index];
                                        laser_ref_previousVal = desired_temperature_C;
                                        laser_ref_currentVal = desired_temperature_C;
                                        laser_ref_futureVal = desired_temperature_C;

                                    }
                                    else {
                                        temperature_c_reference = 0.0; // Set power to 0 if out of bounds
                                        laser_ref_previousVal = temperature_c_reference;
                                        laser_ref_currentVal = temperature_c_reference;
                                        laser_ref_futureVal = temperature_c_reference;
                                    }

                                    laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                                    laserData_cmdW[loop_counter] = laser_power_currentVal;
                                    enable_pid = true;

                                    // Increment the index safely
                                    if (laserPower_index < laserRefTempStartSmooth.size()) {
                                        laserPower_index++;
                                    }

                                    laserController_referenceRawTemp[loop_counter] = temperature_c_reference;
                                }
                                
                                // Block to check if the temperature is more than 800C to begin deposition
                                if (temperature_c_currentVal >= 800.0 )
                                { 
                                    if(flag_execute_queue == 1) // Resume the Aerotech Motion
                                    {   
                                        // This will release pause 2 and will move home stage to start position.
                                        if (!Automation1_CommandQueue_Resume(commandQueue)) { std::cout << "Error: Automation1 Failed to run Automation1_CommandQueue_Resume Resume Pause 2. \n"; }
                                        printf("10 sec - start printing glass \n");
                                        flag_execute_queue = 0;
                                    }

                                 // Ensure that open loop controller is disabled and closed loop is enabled
                                    openLoopConstantLaserPowerEnable = false;
                                    closedLoopControllerEnable = true;

                                }

                            }

                            // Hybrid Closed loop start and Open loop deposit
                            if(closedLoopStartAndOpenLoopDepositEnable)
                            {
                                // Enable the closed loop controller with laser reference trajectory generation and then enabling print when temperature reaches 800C or above
                                { // Block to generate smooth reference trajectory
                                    desired_temperature_C = desired_temperature_celcius;
                                    if(laserPower_index == 1)
                                    {
                                    
                                    generateLaserReferenceSignal(desired_temperature_C,temperature_c_currentVal);
                                    }
                            

                                    if (laserPower_index > 0 && laserPower_index < laserRefTempStartSmooth.size() - 1) {
                                        
                                        temperature_c_reference = laserRefTempStartSmooth[laserPower_index];
                                        laser_ref_previousVal = laserRefTempStartSmooth[laserPower_index-1];
                                        laser_ref_currentVal = laserRefTempStartSmooth[laserPower_index];
                                        laser_ref_futureVal = laserRefTempStartSmooth[laserPower_index+1];


                                    } else if (laserPower_index > 0) 
                                    {
                                        temperature_c_reference = laserRefTempStartSmooth[laserPower_index];
                                        laser_ref_previousVal = desired_temperature_C;
                                        laser_ref_currentVal = desired_temperature_C;
                                        laser_ref_futureVal = desired_temperature_C;

                                    }
                                    else {
                                        temperature_c_reference = 0.0; // Set power to 0 if out of bounds
                                        laser_ref_previousVal = temperature_c_reference;
                                        laser_ref_currentVal = temperature_c_reference;
                                        laser_ref_futureVal = temperature_c_reference;
                                    }

                                    laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                                    laserData_cmdW[loop_counter] = laser_power_currentVal;
                                    enable_pid = true;

                                    // Increment the index safely
                                    if (laserPower_index < laserRefTempStartSmooth.size()) {
                                        laserPower_index++;
                                    }

                                    laserController_referenceRawTemp[loop_counter] = temperature_c_reference;
                                }
                                
                                // Block to check if the temperature is more than 800C to begin deposition
                                if (temperature_c_currentVal >= 800.0 )
                                { 
                                    if(flag_execute_queue == 1) // Resume the Aerotech Motion
                                    {   
                                        // This will release pause 2 and will move home stage to start position.
                                        if (!Automation1_CommandQueue_Resume(commandQueue)) { std::cout << "Error: Automation1 Failed to run Automation1_CommandQueue_Resume Resume Pause 2. \n"; }
                                        printf("10 sec - start printing glass \n");
                                        flag_execute_queue = 0;
                                    }

                                 // Ensure that open loop controller is enabled and closed loop is disabled
                                    openLoopConstantLaserPowerEnable = true;
                                    closedLoopControllerEnable = false;
                                    closedLoopStartAndOpenLoopDepositEnable = false;

                                    ILC_PowerUpdateEnable = false;


                                    if(openLoopConstantLaserPowerEnable)  // Setup OpenLoop Power
                                        {
                                            desired_temperature_C = 0.0;
                                            temperature_c_reference = 0;
                                            laser_power_currentVal = desired_laserpower_watt;
                                            AO1_cmd[0] = convertCmdWattToSetPointVolt(laser_power_currentVal); 
                                            laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                                            laserData_cmdW[loop_counter] = laser_power_currentVal;
                                            enable_pid = false;
                                            laserController_referenceRawTemp[loop_counter] = temperature_c_reference;
                                            enable_pid = false;
                                        }
                                }



                            }
                                   
                            


                        }

                    
                    // if (time_diff >=  20.0) 
                    //     {

                    //         if(openLoopConstantLaserPowerEnable)  // Setup OpenLoop Power
                    //                 {
                    //                     desired_temperature_C = 0.0;
                    //                     temperature_c_reference = 0;
                    //                     laser_power_currentVal = desired_laserpower_watt;
                    //                     AO1_cmd[0] = convertCmdWattToSetPointVolt(laser_power_currentVal); 
                    //                     laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                    //                     laserData_cmdW[loop_counter] = laser_power_currentVal;
                    //                     enable_pid = false;
                    //                     laserController_referenceRawTemp[loop_counter] = temperature_c_reference;
                    //                     enable_pid = false;
                    //                 }
                            
                    //         if(closedLoopControllerEnable) // Setup Close Loop Reference Temperature
                    //         {
                                
                    //             temperature_c_reference = desired_temperature_C; // Set power to 0 if out of bounds
                    //             laser_ref_previousVal = temperature_c_reference;
                    //             laser_ref_currentVal = temperature_c_reference;
                    //             laser_ref_futureVal = temperature_c_reference;
                                
                    //             enable_pid = true;
                    //         }
                            
                    //     // Chirp Signal for system identification
                    //         // if(openLoopConstantLaserPowerEnable)  // Setup OpenLoop Power
                    //         // {
                    //         //     desired_temperature_C = 0.0;
                    //         //     temperature_c_reference = 0;
                    //         //     // laser_power_currentVal = 259.0; // Defined Above

                    //         //     if(false) // Call Chirp Signal to Update Power
                    //         //     {
                    //         //         if (chirp_index < kChirpSamples)
                    //         //         {
                    //         //             laser_power_currentVal = power[chirp_index];
                    //         //             chirp_index++;  // move to next sample
                    //         //         }
                    //         //         else
                    //         //         {
                    //         //             laser_power_currentVal = 0.0;  // out of range, use 0 W
                    //         //         }

                    //         //     }

                    //         //     laser_power_currentVal = 35.0;


                    //         //     AO1_cmd[0] = convertCmdWattToSetPointVolt(laser_power_currentVal); 
                    //         //     laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                    //         //     laserData_cmdW[loop_counter] = laser_power_currentVal;
                    //         //     enable_pid = false;
                    //         //     laserController_referenceRawTemp[loop_counter] = temperature_c_reference;
                    //         //     enable_pid = false;

                    //         //     laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                    //         //     laserData_cmdW[loop_counter] = laser_power_currentVal;
                    //         //     enable_pid = false;

                    //         // }

                         
                    //     }



                    if (aerotech_z_axis_DO[loop_counter] == 5) // 40 W constant power retraction
                        {
                                temperature_c_reference = 0;
                                laser_power_currentVal = desired_laserpower_watt;
                                AO1_cmd[0] = convertCmdWattToSetPointVolt(laser_power_currentVal); 
                                laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                                laserData_cmdW[loop_counter] = laser_power_currentVal;
                                enable_pid = false;
                                laserController_referenceRawTemp[loop_counter] = temperature_c_reference;
                                enable_pid = false;
                        }
                    
                  

                    if (aerotech_z_axis_DO[loop_counter] == 0) // When Aerotech Program Ends
                        {
                                temperature_c_reference = 0;
                                laser_power_currentVal = 0;
                                AO1_cmd[0] = convertCmdWattToSetPointVolt(laser_power_currentVal); 
                                laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                                laserData_cmdW[loop_counter] = laser_power_currentVal;
                                enable_pid = false;
                                laserController_referenceRawTemp[loop_counter] = temperature_c_reference;
                                enable_pid = false;
                                AO1_cmd[0] = 0.0;

                            // Any other shutdown steps...

                            // Exit the loop
                            total_loop_iterations = loop_counter;
                        }




                    #pragma region TemperatureControlLoop
                    // enable_pid = true;
                    if(enable_pid)
                    {  // pid_error = temperature_c_reference - temperature_c_currentVal;
                    // pid_error_integral = pid_error_integral + pid_error * pid_interval_dt;
                    // laser_power_currentVal = pid_gain_kp*(pid_error) + pid_gain_ki*(pid_error_integral);
                    // laser_power_currentVal = laser_power_prevVal + pid_gain_kp*(temperature_c_prevVal-temperature_c_currentVal) + pid_gain_ki*(  (2*temperature_c_reference - temperature_c_currentVal - temperature_c_prevVal)*pid_interval_dt/2  );
                       

                    // laser_ref_previousVal = temperature_c_reference;
                    // laser_ref_currentVal = temperature_c_reference;
                    // laser_ref_futureVal = temperature_c_reference;   

                       if(true) // PID Controller
                       {
                        laser_power_prevVal = laserData_cmdW[loop_counter-1];
                        laser_power_currentVal = laser_power_prevVal + pid_gain_kp*(-temperature_c_currentVal + temperature_c_prevVal) + pid_gain_ki*(temperature_c_reference - temperature_c_prevVal)*pid_interval_dt;
                       }
                       if(true) // General Tracking Controller with Internal Model Principle
                       {
                        laser_power_prevVal = laserData_cmdW[loop_counter-1];
                        laser_power_currentVal = laser_power_prevVal + ((1/0.6304))*
                                                 ( (laser_ref_futureVal -1.8296*laser_ref_currentVal+0.8296*laser_ref_previousVal) +
                                                    (1.8296+alpha_1)*(laser_ref_currentVal-temperature_c_currentVal) + (-0.8296 + alpha_0)*(laser_ref_previousVal-temperature_c_prevVal) );                                
                            
                       }

                        AO1_cmd[0] = convertCmdWattToSetPointVolt(laser_power_currentVal); 
                        laser_power_currentVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                        laserData_cmdW[loop_counter] = laser_power_currentVal;
                        laserController_referenceRawTemp[loop_counter] = temperature_c_reference;

                    }
                    else
                    {
                    //    cmd_laser_power_watt = 0.0;
                    //     laserData_cmdW[loop_counter] = cmd_laser_power_watt;
                    //     AO1_cmd[0] = convertCmdWattToSetPointVolt(cmd_laser_power_watt); 
                    //      AO1_cmd[0] = 0.0;
                        laserController_referenceRawTemp[loop_counter] = 0.0;
                    }

                    #pragma endregion

                }
                else
                AO1_cmd[0] = 0.0;
               

                // if (loop_counter*sample_period_s < 10)
                //     AO1_cmd[0] = 0.0;
                // else
                //     AO1_cmd[0] = 2.0;
                    laser_power_prevVal = convertSetPointVoltToCmdWatt(AO1_cmd[0]);
                    DAQmxErrChk(DAQmxWriteAnalogF64(taskHandleB, 1, 1, 10.0, DAQmx_Val_GroupByChannel, AO1_cmd, NULL, NULL));
                    laserData_cmdV[loop_counter] = AO1_cmd[0];
                    DAQmxErrChk (DAQmxReadAnalogF64(taskHandleC,1,10.0,DAQmx_Val_GroupByChannel,Ain,8,&sampsPerChanRead,NULL));
                    laserData_fbkV[loop_counter] = Ain[0];
                    laserData_fbkW[loop_counter] = convertPDVoltToFbkWatt(Ain[0]);

                    confocalData_distance[loop_counter] = Ain[2];
                    confocalData_intensity[loop_counter] = Ain[3];

                    forceSensorData_Z[loop_counter] = Ain[4];
                    
                    
                    
                #pragma endregion

                #pragma region acquireForceSensorData

                        // std::vector<float64> forceSensor3AxisData_X(num_samples_mem_allocation, 0.0); // Vector to store force sensor data 
                        // std::vector<float64> forceSensor3AxisData_Y(num_samples_mem_allocation, 0.0); // Vector to store force sensor data 
                        // std::vector<float64> forceSensor3AxisData_Z(num_samples_mem_allocation, 0.0); // Vector to store force sensor data 

                        forceSensor3AxisData_X[loop_counter] = Ain[5];
                        forceSensor3AxisData_Y[loop_counter] = Ain[6];
                        forceSensor3AxisData_Z[loop_counter] = Ain[7];

                #pragma endregion
          
                // ******************** RT TASK END
                clock_gettime(CLOCK_MONOTONIC, &current_timestamp.end_time);
                timestamps[loop_counter] = current_timestamp;
        
                wait_rest_of_period(&pinfo); // Wait for the rest of the period
                
                clock_gettime(CLOCK_MONOTONIC, &current_timestamp.end_time_loop);
                timestamps[loop_counter] = current_timestamp;

                loop_counter++;
                loopIterations[loop_counter] = loop_counter;
        }
      

        #pragma region real_time_loop_closure
       
        // // disconnect to sensor
        //     std::cout << "Disconnect" << std::endl;
        //     if ((ret = hLLT->Disconnect()) < GENERAL_FUNCTION_OK) {
        //         std::cout << "Error while disconnecting to camera - Error " << ret << "!" << std::endl;
        //     }

        //     cleanup:
        //         delete hLLT;
        //         CInterfaceLLT::FreeEvent(event);
        //   #pragma region shutdown_thermalCamera // Proper closure of optris thermal camera
        //         thermalCameraEnable = true;
        //         if(thermalCameraEnable)
        //              ::evo_irimager_terminate();
        //         #pragma endregion

        AO1_cmd[0] = {0.0};
        DAQmxErrChk (DAQmxWriteAnalogF64(taskHandleB,1,1,10.0,DAQmx_Val_GroupByChannel,AO1_cmd,NULL,NULL)); // Turn off laser

        Error:
        if( DAQmxFailed(error) )
            DAQmxGetExtendedErrorInfo(errBuff,2048);
           // printf("B\n");
        // if( taskHandle!=0 )  {
        //     printf("C1\n");
        //     DAQmxStopTask(taskHandle);
        //     printf("C2\n");
        //     DAQmxClearTask(taskHandle);
        //     printf("C3\n");
        // }
        if( taskHandleB!=0 ) {
                 //printf("D1\n");
                DAQmxStopTask(taskHandleB);
                //printf("D2\n");
                DAQmxClearTask(taskHandleB);
               // printf("D\n");
                }

        if( taskHandleC!=0 )  {
            //printf("E1\n");
		DAQmxStopTask(taskHandleC);
		DAQmxClearTask(taskHandleC);
      //  printf("E\n");
        
	    }

        // if( taskHandleD!=0 )  {
        //     printf("E1\n");
		// DAQmxStopTask(taskHandleD);
		// DAQmxClearTask(taskHandleD);
        // printf("E\n");
        
	    // }
       // printf("F\n");


        if( DAQmxFailed(error) )
            {       printf("G1\n");
                printf("DAQmx Error: %s\n",errBuff);
               // printf("G\n");
            }

        #pragma region shutdown_thermalCamera // Proper closure of optris thermal camera
                thermalCameraEnable = true;
                if(thermalCameraEnable)
                    ::evo_irimager_terminate();
        #pragma endregion


        #pragma region shutdown_aerotech
            Automation1_StatusConfig_Destroy(statusConfig_captureAerotechData);
            if (!Automation1_CommandQueue_WaitForEmpty(commandQueue, -1)) { /* handle error */ }
            if (!Automation1_CommandQueue_End(commandQueue, -1)) { /* handle error */ }
            commandQueue = NULL;
            stopProgram();
            showProgramStatus();
            // disableAxis(0);
            // disableAxis(1);
            // disableAxis(2);
            // disableAxis(3);
            // stopController();
            disconnectFromController();
        #pragma endregion

        #pragma region ReleaseVisualCamera
        ptrTriggerMode = nodeMap.GetNode("TriggerMode");
        ptrTriggerModeOff = ptrTriggerMode->GetEntryByName("Off");
        ptrTriggerMode->SetIntValue(ptrTriggerModeOff->GetValue());
        pCam->EndAcquisition();
        // Cleanup: release the camera
        pCam->DeInit();
        pCam = nullptr;  // Ensure that the smart pointer is cleared
        camList.Clear();
        // Release the system instance
        system->ReleaseInstance();
        cout << "Camera and system resources have been released." << endl;
        #pragma endregion


        printf("End of program, press Enter key to quit\n");
        // getchar();
        return NULL; // Return NULL as this function does not provide an output
        #pragma endregion

        #pragma endregion
}

int main() 
{
    #pragma region storageFolderCreation
  
    std::cout << "---------------------------------\n";
    if(!std::filesystem::exists(folderPath))
        {
            // Attempt to create the folder
            try {
                if (std::filesystem::create_directories(folderPath)) {
                    std::cout << "Folder created successfully: " << folderPath << std::endl;
                } else {
                    std::cerr << "Failed to create folder: " << folderPath << std::endl;
                    return 1; // Exit if unable to create the folder
                }
            } catch (const std::filesystem::filesystem_error& e) {
                std::cerr << "Error creating folder: " << e.what() << std::endl;
                return 1; // Exit if error occurs
            }
        }

    #pragma endregion

        
    #pragma region RL_OptimizationAndThreadCreation // Functions to optimize rt program and run the rt-cyclic task   
        // Lock memory to ensure all memory pages are resident in RAM and not paged to swap space (HDD/SSD).
        mlockall(MCL_CURRENT | MCL_FUTURE);

        // Define variables for thread attributes and scheduling parameters.
        /*When working with threads in C++ using the POSIX threads (pthreads) library, each thread can have its own attributes.
         These attributes can specify behaviors like the thread's scheduling policy, stack size, or which CPU cores it's allowed to run on.
         The pthread_attr_t type is a data structure used to specify these attributes when creating a thread. 
         Think of it as a container that holds various settings for a thread.*/
        pthread_attr_t attr;           // Thread attributes object.
        struct sched_param param;      // Structure to hold scheduling parameters.

        // Initialize the thread attribute object to the default values.
        pthread_attr_init(&attr);      // No inputs, modifies 'attr'.
                
        // Set the thread scheduling policy to FIFO (First In, First Out).
        pthread_attr_setschedpolicy(&attr, SCHED_FIFO);  // Inputs: attribute object and policy, no outputs.

        // Retrieve and set the maximum scheduling priority for the FIFO policy.
        param.sched_priority = sched_get_priority_max(SCHED_FIFO);  // Input: policy, output: max priority for the policy.

        // Apply the scheduling parameters to the thread attributes.
        pthread_attr_setschedparam(&attr, &param);  // Inputs: attribute object and scheduling parameters, no outputs.

        // Set the inheritance attribute to ensure that the thread uses the attributes specified by 'attr'.
        pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);  // Inputs: attribute object and inheritance setting, no outputs.

        // Initialize the CPU set to be empty and then set CPU 0 in the set.
        cpu_set_t cpuset;               // CPU set object.
        CPU_ZERO(&cpuset);              // Initializes the CPU set to be empty, no inputs/outputs.
        CPU_SET(0, &cpuset);            // Adds CPU 4 to the CPU set, modifies 'cpuset'.

        // Apply the CPU affinity settings to the thread attributes so the thread runs on CPU 0.
        pthread_attr_setaffinity_np(&attr, sizeof(cpu_set_t), &cpuset);  // Inputs: attribute object, size of CPU set, and CPU set object, no outputs.

        // Define a variable to hold the thread ID.
        pthread_t thread_id;            // Thread ID variable.


        // Create the thread with the specified attributes and start it on the function 'simple_cyclic_task'.
        if (pthread_create(&thread_id, &attr, &simple_cyclic_task, NULL)) {
        // On failure, print an error message. 'strerror(errno)' provides a human-readable string for the last error.
        std::cerr << "Error creating real-time thread: " << strerror(errno) << std::endl;
        // Destroy the thread attribute object if thread creation fails.
        pthread_attr_destroy(&attr);  // Input: attribute object, no outputs.
        return 1;                     // Exit the program with an error status.
        }

        // Destroy the thread attribute object as it's no longer needed after the thread is created.
        pthread_attr_destroy(&attr);     // Input: attribute object, no outputs.
        //printf("Place C1");
        // Wait for the thread to terminate.
        pthread_join(thread_id, NULL);   // Inputs: thread ID and NULL (no output parameter), no outputs.
    
    #pragma endregion

    #pragma region storageWrite2Folder // Write to file and change directory permissions
        std::cout<<"Writing to file: \n";
        std::ofstream outfile(filename);

        // Open the second file for linescanner data
        // std::ofstream outfile_linescan("linescan_data.csv");
        // outfile_linescan << "IterationNum(unit),Timestamp,XValues,ZValues\n";

        //outfile << "IterationNum(unit),StartTime(sec),StartTime(nanosec),EndTimeProcess(sec),EndTimeProcess(nanosec),EndTimeLoop(sec),EndTimeLoop(nanosec),LaserPowerCommanded(V),LaserPowerCommanded_NoLim(W),LaserPowerFbk(V),LaserPowerFbk(W),OptrisMaxTemp(C),Aerotech_FbkPos_X(mm),Aerotech_FbkPos_Y(mm),Aerotech_FbkPos_Z(mm)\n";

        outfile << "IterationNum(unit),"
        << "StartTime(sec),StartTime(nanosec),"
        << "EndTimeProcess(sec),EndTimeProcess(nanosec),"
        << "EndTimeLoop(sec),EndTimeLoop(nanosec),"
        << "LaserPowerCommanded(V),LaserPowerCommanded_NoLim(W),"
        << "LaserPowerFbk(V),LaserPowerFbk(W),"
        << "OptrisWorkzoneRawTemp(C),OptrisObservedMaxTemp(C),OptrisWorkzoneCorrectedTemp(C),OptrisObservationAngle(deg),"
        << "ReferenceRawTemp(C),"
        << "ConfocalDistance(um),ConfocalIntensity(%),"
        << "ForceSensor(N),"
        << "Aerotech_FbkPos_X(mm),Aerotech_FbkPos_Y(mm),Aerotech_FbkPos_Z(mm),"
        << "Aerotech_FbkPos_F(deg),"
        << "Aerotech_FbkVel_X(mm/s),Aerotech_FbkVel_Y(mm/s),Aerotech_FbkVel_Z(mm/s),"
        << "Aerotech_FbkVel_F(deg/s),"
        << "Aerotech_FbkAcc_X(mm/s²),Aerotech_FbkAcc_Y(mm/s²),Aerotech_FbkAcc_Z(mm/s²),"
        << "Aerotech_FbkAcc_F(deg/s²),"
        << "Aerotech_CmdPos_X(mm),Aerotech_CmdPos_Y(mm),Aerotech_CmdPos_Z(mm),"
        << "Aerotech_CmdPos_F(deg),"
        << "Aerotech_CmdVel_X(mm/s),Aerotech_CmdVel_Y(mm/s),Aerotech_CmdVel_Z(mm/s),"
        << "Aerotech_CmdVel_F(deg/s),"
        << "Aerotech_CmdAcc_X(mm/s²),Aerotech_CmdAcc_Y(mm/s²),Aerotech_CmdAcc_Z(mm/s²),"
        << "Aerotech_CmdAcc_F(deg/s²),"
        << "AerotechStatusDOZ(4Bit),"
        << "3AxisForceSensorX(N),3AxisForceSensorY(N),3AxisForceSensorZ(N)"
        << "\n";

        for (size_t i = 0; i < timestamps.size(); ++i) {
                const auto& ts = timestamps[i];
                int32 loopItr = loopIterations[i];
                float64 laserData_cmdV_val = laserData_cmdV[i];
                float64 laserData_cmdW_val = laserData_cmdW[i];
                float64 laserData_fbkV_val = laserData_fbkV[i];
                float64 laserData_fbkW_val = laserData_fbkW[i];
                float64 optris_workzoneRawTemp_val = optris_workzoneRawTemp[i];
                float64 optris_observedMaxTemp_val = optris_observedMaxTemp[i];
                float64 optris_workzoneCorrectedTemp_val = optris_workzoneCorrectedTemp[i];
                float64 optris_observationAngle_val = optris_observationAngle[i];
                float64 laserController_referenceRawTemp_val = laserController_referenceRawTemp[i];
                // float64 aerotech_z_axis_pos_val = aerotech_z_axis_posFbk[i];
                // float64 aerotech_y_axis_pos_val = aerotech_y_axis_posFbk[i];
                // float64 aerotech_x_axis_pos_val = aerotech_x_axis_posFbk[i];
                float64 confocalData_distance_val = confocalData_distance[i];
                float64 confocalData_intensity_val = confocalData_intensity[i];

                float64 forceSensorData_Z_val = forceSensorData_Z[i];

                float64 aerotech_z_axis_pos_val = aerotech_z_axis_posFbk[i];
                float64 aerotech_y_axis_pos_val = aerotech_y_axis_posFbk[i];
                float64 aerotech_x_axis_pos_val = aerotech_x_axis_posFbk[i];
                float64 aerotech_f_axis_pos_val = aerotech_f_axis_posFbk[i];

                float64 aerotech_z_axis_vel_val = aerotech_z_axis_velFbk[i];
                float64 aerotech_y_axis_vel_val = aerotech_y_axis_velFbk[i];
                float64 aerotech_x_axis_vel_val = aerotech_x_axis_velFbk[i];
                float64 aerotech_f_axis_vel_val = aerotech_f_axis_velFbk[i];

                float64 aerotech_z_axis_acc_val = aerotech_z_axis_accFbk[i];
                float64 aerotech_y_axis_acc_val = aerotech_y_axis_accFbk[i];
                float64 aerotech_x_axis_acc_val = aerotech_x_axis_accFbk[i];
                float64 aerotech_f_axis_acc_val = aerotech_f_axis_accFbk[i];

                float64 aerotech_z_axis_pos_cmd_val = aerotech_z_axis_posCmd[i];
                float64 aerotech_y_axis_pos_cmd_val = aerotech_y_axis_posCmd[i];
                float64 aerotech_x_axis_pos_cmd_val = aerotech_x_axis_posCmd[i];
                float64 aerotech_f_axis_pos_cmd_val = aerotech_f_axis_posCmd[i];

                float64 aerotech_z_axis_vel_cmd_val = aerotech_z_axis_velCmd[i];
                float64 aerotech_y_axis_vel_cmd_val = aerotech_y_axis_velCmd[i];
                float64 aerotech_x_axis_vel_cmd_val = aerotech_x_axis_velCmd[i];
                float64 aerotech_f_axis_vel_cmd_val = aerotech_f_axis_velCmd[i];

                float64 aerotech_z_axis_acc_cmd_val = aerotech_z_axis_accCmd[i];
                float64 aerotech_y_axis_acc_cmd_val = aerotech_y_axis_accCmd[i];
                float64 aerotech_x_axis_acc_cmd_val = aerotech_x_axis_accCmd[i];
                float64 aerotech_f_axis_acc_cmd_val = aerotech_f_axis_accCmd[i];

                float64 aerotech_z_axis_DO_val = aerotech_z_axis_DO[i];


                float64 forceSensor3AxisData_X_val = forceSensor3AxisData_X[i];
                float64 forceSensor3AxisData_Y_val = forceSensor3AxisData_Y[i];
                float64 forceSensor3AxisData_Z_val = forceSensor3AxisData_Z[i];

                



                outfile << loopItr << ","
                        << ts.start_time.tv_sec << "," << ts.start_time.tv_nsec << ","
                        << ts.end_time.tv_sec << "," << ts.end_time.tv_nsec << ","
                        << ts.end_time_loop.tv_sec << "," << ts.end_time_loop.tv_nsec << "," 
                        << laserData_cmdV_val << "," << laserData_cmdW_val << "," 
                        << laserData_fbkV_val << "," << laserData_fbkW_val << "," 
                        << optris_workzoneRawTemp_val << "," << optris_observedMaxTemp_val << "," << optris_workzoneCorrectedTemp_val << "," << optris_observationAngle_val << ","
                        << laserController_referenceRawTemp_val << "," 
                        << confocalData_distance_val << "," << confocalData_intensity_val << "," 
                        << forceSensorData_Z_val << ","
                        << aerotech_x_axis_pos_val << "," << aerotech_y_axis_pos_val << "," << aerotech_z_axis_pos_val << ","
                        << aerotech_f_axis_pos_val << ","
                        << aerotech_x_axis_vel_val << "," << aerotech_y_axis_vel_val << "," << aerotech_z_axis_vel_val << ","
                        << aerotech_f_axis_vel_val << ","
                        << aerotech_x_axis_acc_val << "," << aerotech_y_axis_acc_val << "," << aerotech_z_axis_acc_val << ","
                        << aerotech_f_axis_acc_val << ","
                        << aerotech_x_axis_pos_cmd_val << "," << aerotech_y_axis_pos_cmd_val << "," << aerotech_z_axis_pos_cmd_val << ","
                        << aerotech_f_axis_pos_cmd_val << ","
                        << aerotech_x_axis_vel_cmd_val << "," << aerotech_y_axis_vel_cmd_val << "," << aerotech_z_axis_vel_cmd_val << ","
                        << aerotech_f_axis_vel_cmd_val << ","
                        << aerotech_x_axis_acc_cmd_val << "," << aerotech_y_axis_acc_cmd_val << "," << aerotech_z_axis_acc_cmd_val << ","
                        << aerotech_f_axis_acc_cmd_val << ","
                        << aerotech_z_axis_DO_val << ","
                        << forceSensor3AxisData_X_val << "," << forceSensor3AxisData_Y_val << "," << forceSensor3AxisData_Z_val
                        << "\n";
                       // << aerotech_x_axis_pos_val << ","  << aerotech_y_axis_pos_val << "," << aerotech_z_axis_pos_val <<"\n";

                // outfile_linescan << loopItr << ","
                //      << lineScanData_timestamp[i][0] << ",";  // Save the timestamp
                // // Save the X values
                //     for (size_t j = 0; j < lineScanData_profileX[i].size(); ++j) {
                //         outfile_linescan << lineScanData_profileX[i][j];
                //         if (j < lineScanData_profileX[i].size() - 1) {
                //             outfile_linescan << ";";  // Separate X values with semicolons
                //         }
                //     }

                //     outfile_linescan << ",";  // Separate X values from Z values

                // // Save the Z values
                //     for (size_t j = 0; j < lineScanData_profileZ[i].size(); ++j) {
                //         outfile_linescan << lineScanData_profileZ[i][j];
                //         if (j < lineScanData_profileZ[i].size() - 1) {
                //             outfile_linescan << ";";  // Separate Z values with semicolons
                //         }
                //     }

                //     outfile_linescan << "\n";

        }

        
        outfile.close();
       // outfile_linescan.close();

        // Save the temperature data in csv files

        // std::string folder = "DatasetExp/Exp4_CloseLoopControl/Test3_ImageStore";
        // std::string file = "CPPlog.csv";
        // std::filesystem::path folderPath(folder);
        // std::filesystem::path filePath = folderPath / file;
        // std::string filename = filePath.string();

       //  Define the subfolder where the CSV files will be saved

        if(bool_saveThermalData)
        {
            std::string subfolder = "ThermalDataSlices";
            std::filesystem::path subfolderPath = folderPath / subfolder;

            // Create the subfolder if it doesn't exist
            std::filesystem::create_directory(subfolderPath);

        
            // Save each slice to a CSV file
            for (int loop_counter = 0; loop_counter < num_samples_mem_allocation; ++loop_counter) {
                
                if(optris_TempSlices[loop_counter][1][1] > 0.1) // Check if there is real data in frame or just 0's, if its 0s skip the frame save.
                {
                    // Create the filename using loop_counter
                    std::ostringstream filename_thermal;
                    filename_thermal << "slice_" << std::setw(4) << std::setfill('0') << loop_counter << ".csv";

                    // Combine the subfolder path with the filename
                    std::filesystem::path fullFilePath = subfolderPath / filename_thermal.str();

                    // Open the file for writing
                    std::ofstream file(fullFilePath.string());

                    if (file.is_open()) {
                        // Write the slice to the file
                        for (int y = 0; y < 120; ++y) {
                            for (int x = 0; x < 640; ++x) {
                                file << std::fixed << std::setprecision(2) << optris_TempSlices[loop_counter][x][y];
                                if (x < 640 - 1) {
                                    file << ",";
                                }
                            }
                            file << "\n";
                        }
                        file.close();
                        // std::cout << "Data saved to " << filename_thermal.str() << std::endl;
                    } else {
                        std::cerr << "Unable to open file " << filename_thermal.str() << std::endl;
                    }
                }
            }

        }


        #pragma region saveVisualCameraImages

    std::string imagesSubfolder = "images";
    std::filesystem::path folderPath(folder);
    // Construct the path for the images subfolder
    std::filesystem::path imagesFolderPath = folderPath / imagesSubfolder;

    // Ensure the images folder exists
    if (!std::filesystem::exists(imagesFolderPath)) {
        // Attempt to create the images folder
        std::filesystem::create_directories(imagesFolderPath);
    }
    
    int skip_images = 0;

    for (int i = 0; i < maxImages; ++i) 
    {   
        if(i+skip_images<maxImages)
        i = i+skip_images;
        if (imageStorage[i]) { // Check if the pointer is not null
            std::ostringstream filepath;
            // Adjust the filepath to include the images subfolder
            filepath << imagesFolderPath.string() << "/Acquisition" << i + 1 << ".jpeg"; // Construct file path
            imageStorage[i]->Save(filepath.str().c_str()); // Save the image
        }
    }

    #pragma endregion
        
#pragma region saveMainScript

    std::string programSubfolder = "mainProgram";
    // std::filesystem::path folderPath(folder);
    // Construct the path for the images subfolder
    std::filesystem::path programFolderPath = folderPath / programSubfolder;

    // Ensure the images folder exists
    if (!std::filesystem::exists(programFolderPath)) {
        // Attempt to create the images folder
        std::filesystem::create_directories(programFolderPath);
    }

    // Build the path to main.cpp (which is one level up from DatasetExp)
    std::filesystem::path sourceFilePath = "mainProgram.cpp";

    // Destination path for copying main.cpp
    std::filesystem::path destinationFilePath = programFolderPath / "mainProgram.cpp";

    // Copy main.cpp to the results folder
    try {
        std::filesystem::copy_file(sourceFilePath, destinationFilePath, std::filesystem::copy_options::overwrite_existing);
        std::cout << "Program file 'mainProgram.cpp' copied successfully to the results folder.\n";
    } catch (const std::filesystem::filesystem_error& e) {
        std::cerr << "Failed to copy 'mainProgram.cpp': " << e.what() << '\n';
    }


    std::filesystem::path destinationFilePath_gcode = programFolderPath / "aerotechGCode-Active.txt";
    std::filesystem::path sourceFilePath_Gcode = "aerotechGCode-Active.txt";

    try {
        std::filesystem::copy_file(sourceFilePath_Gcode, destinationFilePath_gcode, std::filesystem::copy_options::overwrite_existing);
        std::cout << "Program file 'aerotechGCode-Active.txt' copied successfully to the results folder.\n";
    } catch (const std::filesystem::filesystem_error& e) {
        std::cerr << "Failed to copy 'aerotechGCode-Active.cpp': " << e.what() << '\n';
    }



#pragma endregion

        munlockall();  

        // Set previliges for the save folder to user level.
        std::string command = "sudo chown -R dmf:dmf /home/dmf/Documents/GitHub";
        int result = std::system(command.c_str());
        if (result != 0) {
            std::cerr << "Failed to change ownership. Error code: " << result << std::endl;
        }
        std::cout << "Directory permissions for '" << folder << "' changed successfully." << std::endl;
        // Set previliges for the save folder to user level. - DONE


    #pragma endregion
    
    return 0;                        // Exit the program with a success status.

}